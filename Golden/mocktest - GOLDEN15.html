<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>InsightPrep - Where Preparation Meets Reflection</title>
  <style>
    /* ============================================
       GLOBAL STYLES & LAYOUT
    ============================================ */
    html, body {
      height: 100%;
      min-height: 100%;
      overflow-x: hidden; /* Prevent horizontal scrollbar */
    }
    
    body {
      font-family: Arial, sans-serif;
      background: #f4f6f8;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      width: 100%;
      box-sizing: border-box;
    }
    
    header {
      background: #0078d7;
      color: white;
      width: 100%;
      padding: 20px;
      text-align: center;
      font-size: 1.5em;
      font-weight: bold;
      line-height: 1.3;
    }
    
    main {
      max-width: 900px;
      width: 95%;
      margin: 20px auto;
      flex: 1 0 auto;
      box-sizing: border-box;
      overflow-x: hidden;
    }

    /* Ensure all elements use border-box sizing */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    /* ============================================
       BUTTONS & CONTROLS
    ============================================ */
    .controls {
      margin: 20px 0;
      text-align: center;
    }
    
    #fileInput { 
      display: none; 
    }
    
    .custom-btn, button {
      background: #0078d7;
      color: white;
      padding: 10px 20px;
      border: 1px solid transparent;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1em;
      transition: all 0.2s ease;
    }
    
    button {
      font-size: 0.95em;
      margin-top: 8px;
    }
    
    /* Ensure Choose DB button has same dimensions as Choose JSON */
    button.custom-btn {
      padding: 10px 20px;
      font-size: 1em;
      margin-top: 0;
    }
    
    .custom-btn:hover, button:hover { 
      background: #005ea3; 
      border: 1px solid #0078d7;
    }

    .custom-btn:focus, button:focus { 
      outline: none;
      border: 1px solid #0078d7;
      box-shadow: 0 0 4px rgba(0,120,215,0.4);
    }
    
    #restart, #restart-bottom, #newtest { 
      margin: 20px 10px; 
      display: none; 
    }

    /* ============================================
       QUESTION CARDS & CONTENT
    ============================================ */
    .file-chosen {
      margin: 10px auto;
      padding: 10px;
      background: #e6ffed;
      border: 1px solid #00a854;
      border-radius: 6px;
      text-align: center;
      font-weight: bold;
      color: #006633;
    }
    
    .question-card {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      border: 1px solid transparent;
    }
    
    .question-card h3 { 
      margin-top: 0; 
    }
    
    /* Question States */
    .disabled { 
      pointer-events: none; 
      opacity: 0.6; 
    }
    
    .active { 
      border: 1px solid #0078d7; 
      box-shadow: 0 0 6px rgba(0,120,215,0.3); 
    }
    
    .locked { 
      pointer-events: none; 
      opacity: 1 !important; 
    }
    
    /* Answer Feedback */
    .correct { 
      color: green; 
      font-weight: bold; 
    }
    
    .wrong { 
      color: red; 
      font-weight: bold; 
    }
    
    .correct-answer {
      color: #2e7d32;
      font-weight: bold;
      margin-top: 8px;
      padding: 6px 10px;
      background: #e8f5e8;
      border-left: 4px solid #4caf50;
      border-radius: 4px;
    }
    
    .explanation { 
      margin-top: 8px; 
      font-style: italic; 
    }
    
    .reference { 
      margin-top: 4px; 
      font-size: 0.9em; 
      color: #333; 
    }

    /* ============================================
       SCORING & MESSAGES
    ============================================ */
    #scoreboard {
      margin: 20px 0;
      font-size: 1.2em;
      text-align: center;
    }
    
    #message {
      font-size: 1.1em;
      margin-top: 10px;
      font-weight: bold;
    }
    
    #message.excellent { color: green; }
    #message.good { color: #0078d7; }
    #message.fair { color: orange; }
    #message.poor { color: red; }

    /* ============================================
       FILTER PANELS
    ============================================ */
    .filter-panel {
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 20px;
      margin: 10px 0 20px 0;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .filter-panel h3 {
      margin-top: 0;
      color: #0078d7;
    }
    
    .filter-section { 
      margin-bottom: 15px; 
    }
    
    /* Topic hierarchy styles */
    .topic-hierarchy {
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 10px;
      background: #fafafa;
    }
    
    .topic-item {
      border-bottom: 1px solid #e0e0e0;
      padding-bottom: 8px;
      margin-bottom: 10px;
    }
    
    .topic-item:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    
    .subtopics-container {
      background: white;
      border-radius: 3px;
      padding: 8px;
      border-left: 1px solid #0078d7;
    }
    
    .topic-checkbox {
      font-weight: bold !important;
    }
    
    .subtopic-checkbox {
      font-size: 0.9em;
      color: #555;
    }
    
    label { 
      cursor: pointer; 
    }

    /* ============================================
       MATCH QUESTIONS & TABLES
    ============================================ */
    .match-table {
      display: table;
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0;
    }
    
    .match-row { 
      display: table-row; 
    }
    
    .match-cell {
      display: table-cell;
      padding: 6px 8px;
      vertical-align: middle;
    }
    
    .match-cell:first-child {
      font-weight: bold;
      width: 40%;
    }
    
    select {
      width: 100%;
      padding: 4px;
    }

    /* ============================================
       TOOLTIP SYSTEM
    ============================================ */
    .tooltip-container {
      position: relative;
      display: inline-block;
    }
    
    .tooltip {
      visibility: hidden;
      position: absolute;
      z-index: 1000;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background-color: #fff3cd;
      color: #856404;
      border: 2px solid #ffeaa7;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      width: 400px;
      max-width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
      font-size: 0.9em;
      opacity: 0;
      transition: opacity 0.3s, visibility 0.3s;
    }
    
    .tooltip::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      margin-left: -8px;
      border-width: 8px;
      border-style: solid;
      border-color: #ffeaa7 transparent transparent transparent;
    }
    
    .tooltip-container:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }
    
    .tooltip h4 {
      margin: 0 0 8px 0;
      color: #856404;
      font-size: 1em;
      text-align: center;
      border-bottom: 1px solid #856404;
      padding: 8px 4px 4px 4px;
      background-color: #fff3cd;
      position: sticky;
      top: 0;
      z-index: 1002;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .tooltip-table {
      width: 100%;
      border-collapse: collapse;
      margin: 8px 0;
      font-size: 0.85em;
      position: relative;
    }
    
    .tooltip-table th {
      background-color: #f8f4e6;
      border: 1px solid #856404;
      padding: 8px 6px;
      text-align: center;
      font-weight: bold;
      font-size: 0.8em;
      position: sticky;
      top: 40px;
      z-index: 1001;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .tooltip-table td {
      border: 1px solid #856404;
      padding: 6px;
      text-align: center;
      font-size: 0.85em;
      background-color: #fefcf7;
    }
    
    .tooltip-table tbody tr:nth-child(even) td {
      background-color: #f9f6f0;
    }
    
    .tooltip-table tbody tr:hover td {
      background-color: #f5f2e8;
    }
    
    .tooltip-table .random-row td {
      font-style: italic;
      background-color: #f0f0f0 !important;
      border-top: 2px solid #999 !important;
    }
    
    .tooltip-summary {
      margin-top: 10px;
      padding: 8px;
      border-top: 2px solid #856404;
      font-weight: bold;
      text-align: center;
      font-size: 0.9em;
      background-color: #f8f4e6;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    /* ============================================
       COPYRIGHT FOOTER
    ============================================ */
    #swamys-footer {
      position: fixed;
      left: 0;
      bottom: 0;
      z-index: 2000;
      background: rgba(255,255,255,0.95);
      color: #444;
      font-size: 13px;
      font-family: inherit;
      padding: 8px 18px 8px 12px;
      box-shadow: 0 -2px 8px rgba(0,0,0,0.07);
      border-top-right-radius: 10px;
      border-top: 1px solid #e0e0e0;
      border-right: 1px solid #e0e0e0;
      min-width: 340px;
      max-width: 90vw;
      line-height: 1.4;
      pointer-events: none;
      user-select: none;
    }
    
    #swamys-footer div { 
      white-space: pre-line; 
    }
    
    #swamys-copyright-card {
      position: fixed;
      left: 18px;
      bottom: 18px;
      z-index: 9999;
      background: rgba(245, 247, 250, 0.97);
      box-shadow: 0 2px 12px rgba(0,0,0,0.10);
      border-radius: 10px;
      padding: 12px 18px 10px 18px;
      min-width: 220px;
      max-width: 320px;
      font-size: 0.98em;
      color: #222;
      font-family: 'Segoe UI', Arial, sans-serif;
      border: 1px solid #e0e0e0;
      opacity: 0.93;
      transition: box-shadow 0.2s;
      pointer-events: auto;
      user-select: none;
      text-align: left;
      display: block;
    }

    #swamys-copyright-card a {
      pointer-events: auto;
      cursor: pointer;
    }
    
    .swamys-copyright-main {
      font-weight: 500;
      margin-bottom: 2px;
      line-height: 1.3;
    }
    
    .swamys-copyright-author, .swamys-copyright-school {
      color: #1976d2;
      font-weight: 600;
    }
    
    .swamys-copyright-email {
      color: #666;
      font-size: 0.9em;
      font-style: italic;
    }
    
    .swamys-copyright-copy {
      font-size: 0.93em;
      color: #666;
      margin-top: 2px;
    }

    /* ============================================
       COPYRIGHT STATES
    ============================================ */
    body.sticky-footer #swamys-copyright-card {
      position: sticky !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      margin: 0 auto !important;
      width: 100vw !important;
      min-width: 0 !important;
      max-width: 100vw !important;
      border-radius: 0 !important;
      box-shadow: none !important;
      background: #f8fafc !important;
      border-top: 1px solid #e0e0e0 !important;
      opacity: 1 !important;
      padding: 12px 0 10px 0 !important;
      text-align: center !important;
      pointer-events: auto !important;
      display: block !important;
    }
    
    body.hide-copyright-card #swamys-copyright-card {
      display: none !important;
    }

    /* ============================================
       RESPONSIVE DESIGN
    ============================================ */
    @media (max-width: 700px) {
      #swamys-copyright-card {
        position: static !important;
        left: unset !important;
        bottom: unset !important;
        width: 100vw !important;
        min-width: 0 !important;
        max-width: 100vw !important;
        border-radius: 0 !important;
        box-shadow: none !important;
        background: #f8fafc !important;
        border-top: 1px solid #e0e0e0 !important;
        opacity: 1 !important;
        margin: 0 !important;
        padding: 12px 0 10px 0 !important;
        text-align: center !important;
        pointer-events: auto !important;
      }
      
      .swamys-copyright-main {
        font-size: 1em;
        margin-bottom: 2px;
      }
      
      .swamys-copyright-copy {
        font-size: 0.93em;
      }
    }
    
    @media (min-width: 701px) {
      body.sticky-footer #swamys-copyright-card {
        position: sticky !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        margin: 0 auto !important;
        width: 100vw !important;
        min-width: 0 !important;
        max-width: 100vw !important;
        border-radius: 0 !important;
        box-shadow: none !important;
        background: #f8fafc !important;
        border-top: 1px solid #e0e0e0 !important;
        opacity: 1 !important;
        padding: 12px 0 10px 0 !important;
        text-align: center !important;
        pointer-events: auto !important;
      }
    }
  </style>
  <!-- Add sql.js library for SQLite in browser -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
</head>
<body>
  <header id="test-title">InsightPrep<br><span style="font-size: 0.75em; font-weight: normal; color: #e6f3ff; margin-top: 5px; display: inline-block;">Where Preparation Meets Reflection</span></header>
  <main>
    <div class="controls">
      <label for="fileInput" class="custom-btn" title="Select a test JSON file to begin. Loads questions and allows you to set filters before starting the test.">📂 Choose JSON</label>
      <input type="file" id="fileInput" accept=".json">
      <button id="chooseDb" class="custom-btn" style="margin-left:10px;" title="Choose questions from the SQLite database. Allows you to set filters and select the number of questions.">🗄️ Choose DB</button>
      <button id="backToOptions" style="display:none; margin-left:10px;" title="Go back to the options page to modify filters or settings without choosing database again.">⬅️ Back to Options</button>
      <button id="restart" style="display:none; margin-left:10px;" title="Restart the current test instantly using the same filters and explanation mode. Does not show the filter screen again.">🔄 Restart Test</button>
      <button id="newTestSameOptions" style="display:none; margin-left:10px;" title="Start a new test with the same filters and number of questions but different set of questions.">🎲 New Questions</button>
      <button id="backToStartFromOptions" style="display:none; margin-left:10px; background-color:#6c757d;" class="custom-btn" title="Return to the start page to see the how-to-use guide and file selection options">← Back to Start Page</button>
    </div>
    <div id="file-chosen"></div>
    
    <!-- Comprehensive How-to-Use Guide -->
    <div id="how-to-use-guide" style="margin: 20px auto; max-width: 1200px; background: linear-gradient(135deg, #f8fafc 0%, #e3f2fd 100%); border-radius: 12px; padding: 25px; border: 1px solid #e1f5fe; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
      
      <!-- Header Section -->
      <div style="text-align: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 2px solid #42a5f5;">
        <h2 style="color: #1565c0; margin: 0 0 10px 0; font-size: 1.6em;">🎯 How to Use InsightPrep</h2>
        <p style="color: #0277bd; margin: 0; font-size: 1.1em; font-weight: 500;">Your Complete Guide to Effective Test Preparation</p>
      </div>
      
      <!-- Three Column Layout -->
      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 25px; margin-bottom: 25px;">
        
        <!-- Column 1: Getting Started -->
        <div style="background: #ffffff; border-radius: 10px; padding: 20px; border: 1px solid #e3f2fd; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
          <div style="display: flex; align-items: center; margin-bottom: 15px;">
            <span style="font-size: 1.5em; margin-right: 10px;">🚀</span>
            <h3 style="color: #1565c0; margin: 0; font-size: 1.2em;">Getting Started</h3>
          </div>
          
          <div style="margin-bottom: 15px;">
            <h4 style="color: #0277bd; margin: 0 0 8px 0; font-size: 0.95em;">📂 Step 1: Load Questions</h4>
            <ul style="margin: 0; padding-left: 15px; font-size: 0.85em; line-height: 1.4; color: #424242;">
              <li><strong>Choose DB:</strong> Load SQLite database files with organized question banks</li>
              <li><strong>Choose JSON:</strong> Load custom JSON files with your own questions</li>
            </ul>
          </div>
          
          <div style="margin-bottom: 15px;">
            <h4 style="color: #0277bd; margin: 0 0 8px 0; font-size: 0.95em;">⚙️ Step 2: Configure Test</h4>
            <ul style="margin: 0; padding-left: 15px; font-size: 0.85em; line-height: 1.4; color: #424242;">
              <li>Select specific topics & subtopics</li>
              <li>Choose question types (MCQ, True/False, etc.)</li>
              <li>Set number of questions (1-500+)</li>
              <li>Pick Random or Balanced selection</li>
            </ul>
          </div>
          
          <div>
            <h4 style="color: #0277bd; margin: 0 0 8px 0; font-size: 0.95em;">📝 Step 3: Take Test</h4>
            <ul style="margin: 0; padding-left: 15px; font-size: 0.85em; line-height: 1.4; color: #424242;">
              <li>Answer questions with instant feedback</li>
              <li>See explanations when you get it wrong</li>
              <li>View final score and performance</li>
            </ul>
          </div>
        </div>
        
        <!-- Column 2: Question Types & Features -->
        <div style="background: #ffffff; border-radius: 10px; padding: 20px; border: 1px solid #e3f2fd; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
          <div style="display: flex; align-items: center; margin-bottom: 15px;">
            <span style="font-size: 1.5em; margin-right: 10px;">🎯</span>
            <h3 style="color: #1565c0; margin: 0; font-size: 1.2em;">Question Types</h3>
          </div>
          
          <div style="margin-bottom: 15px;">
            <h4 style="color: #0277bd; margin: 0 0 8px 0; font-size: 0.95em;">📋 Supported Formats</h4>
            <ul style="margin: 0; padding-left: 15px; font-size: 0.85em; line-height: 1.4; color: #424242;">
              <li><strong>MCQ:</strong> Multiple Choice Questions</li>
              <li><strong>True/False:</strong> Binary choice questions</li>
              <li><strong>Assertion-Reason:</strong> Logic-based questions</li>
              <li><strong>Match the Following:</strong> Pairing exercises</li>
              <li><strong>Cohort-05-MCQ:</strong> Special collections</li>
            </ul>
          </div>
          
          <div style="margin-bottom: 15px;">
            <h4 style="color: #0277bd; margin: 0 0 8px 0; font-size: 0.95em;">✨ Smart Features</h4>
            <ul style="margin: 0; padding-left: 15px; font-size: 0.85em; line-height: 1.4; color: #424242;">
              <li><strong>Balanced Mode:</strong> Equal questions per topic/subtopic</li>
              <li><strong>Try Again:</strong> Retry wrong answers to learn</li>
              <li><strong>Instant Feedback:</strong> Know results immediately</li>
              <li><strong>Explanations:</strong> Learn from mistakes</li>
            </ul>
          </div>
          
          <div>
            <h4 style="color: #0277bd; margin: 0 0 8px 0; font-size: 0.95em;">🔄 Restart Options</h4>
            <ul style="margin: 0; padding-left: 15px; font-size: 0.85em; line-height: 1.4; color: #424242;">
              <li>Restart same test with same questions</li>
              <li>Get new set of questions with same filters</li>
              <li>Change filters and create new test</li>
            </ul>
          </div>
        </div>
        
        <!-- Column 3: Pro Tips & Best Practices -->
        <div style="background: #ffffff; border-radius: 10px; padding: 20px; border: 1px solid #e3f2fd; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
          <div style="display: flex; align-items: center; margin-bottom: 15px;">
            <span style="font-size: 1.5em; margin-right: 10px;">💡</span>
            <h3 style="color: #1565c0; margin: 0; font-size: 1.2em;">Pro Tips</h3>
          </div>
          
          <div style="margin-bottom: 15px;">
            <h4 style="color: #0277bd; margin: 0 0 8px 0; font-size: 0.95em;">🏆 Study Strategies</h4>
            <ul style="margin: 0; padding-left: 15px; font-size: 0.85em; line-height: 1.4; color: #424242;">
              <li>Use <strong>Random mode</strong> for the best learning experience</li>
              <li><strong>Balanced mode</strong> is also an option for equal topic coverage</li>
              <li>Enable explanations to learn from mistakes</li>
              <li>Mix different question types for variety</li>
              <li>Start small, then increase difficulty</li>
            </ul>
          </div>
          
          <div style="margin-bottom: 15px;">
            <h4 style="color: #0277bd; margin: 0 0 8px 0; font-size: 0.95em;">⚡ Performance Tips</h4>
            <ul style="margin: 0; padding-left: 15px; font-size: 0.85em; line-height: 1.4; color: #424242;">
              <li>Review explanations carefully</li>
              <li>Retry wrong answers using "Try Again"</li>
              <li>Focus on weak topics with targeted filters</li>
              <li>Take breaks between long sessions</li>
            </ul>
          </div>
          
          <div>
            <h4 style="color: #0277bd; margin: 0 0 8px 0; font-size: 0.95em;">🔒 Privacy & Security</h4>
            <ul style="margin: 0; padding-left: 15px; font-size: 0.85em; line-height: 1.4; color: #424242;">
              <li>Runs completely offline on your computer</li>
              <li>No internet connection required</li>
              <li>Your data never leaves your device</li>
              <li>100% private and secure</li>
            </ul>
          </div>
        </div>
      </div>
      
      <!-- Bottom Quick Reference -->
      <div style="background: linear-gradient(90deg, #1976d2 0%, #42a5f5 100%); border-radius: 8px; padding: 20px; color: white; text-align: center;">
        <h3 style="margin: 0 0 10px 0; font-size: 1.3em;">🏁 Quick Start</h3>
        <p style="margin: 0 0 15px 0; font-size: 1.05em; opacity: 0.95;">
          <strong>Click "Choose DB" → Select your question database → Configure filters → Set question count → Start Test!</strong>
        </p>
        <div style="display: flex; justify-content: center; gap: 30px; margin-top: 15px; font-size: 0.9em; opacity: 0.9;">
          <span>🚀 <strong>Fast Setup:</strong> 30 seconds</span>
          <span>🔒 <strong>100% Private:</strong> Offline app</span>
          <span>📊 <strong>Instant Results:</strong> Real-time feedback</span>
          <span>🎯 <strong>Customizable:</strong> Your topics, your pace</span>
        </div>
      </div>
    </div>
    
    <div id="filter-panel"></div>
    <div id="test"></div>
    <div id="scoreboard"></div>
    <div style="text-align:center;">
      <button id="backToOptions-bottom" style="display:none; margin-right:10px;" title="Go back to the options page to modify filters or settings without choosing database again.">⬅️ Back to Options</button>
      <button id="restart-bottom" style="display:none; margin-right:10px;" title="Restart the current test instantly using the same filters and explanation mode. Does not show the filter screen again.">🔄 Restart Test</button>
      <button id="newTestSameOptions-bottom" style="display:none; margin-right:10px;" title="Start a new test with the same filters and number of questions but different set of questions.">🎲 New Questions</button>
      <button id="newtest" title="Select a new test file. Clears all current progress and lets you load a different set of questions.">📂 Select New Test</button>
    </div>
  </main>


  <div id="swamys-copyright-card">
    <div class="swamys-copyright-main">
      Architected, Designed &amp; Developed by <span class="swamys-copyright-author">Girish.V</span><br>
      <span class="swamys-copyright-school"><a href="https://www.swamysschool.com" target="_blank" style="color: inherit; text-decoration: none;">Swamy's Group of Schools, Chennai</a></span><br>
      <span class="swamys-copyright-email">contact@swamysschool.com</span>
    </div>
    <div class="swamys-copyright-copy">
      &copy; <span id="swamys-copyright-year"></span>. All rights reserved
    </div>
  </div>
  <script>
    // Show copyright card at bottom left only if browser is maximized; otherwise, sticky footer
    function isWindowMaximized() {
      // Heuristic: window outer size nearly equals screen size
      return (
        Math.abs(window.outerWidth - screen.availWidth) < 8 &&
        Math.abs(window.outerHeight - screen.availHeight) < 8
      );
    }
    function updateCopyrightCardPosition() {
      const body = document.body;
      if (isWindowMaximized()) {
        // When maximized, show as regular positioned card
        body.classList.remove('sticky-footer');
        body.classList.remove('hide-copyright-card');
      } else {
        // When not maximized, always show as sticky footer
        body.classList.add('sticky-footer');
        body.classList.remove('hide-copyright-card');
      }
    }
    window.addEventListener('resize', updateCopyrightCardPosition);
    window.addEventListener('DOMContentLoaded', updateCopyrightCardPosition);
    setTimeout(updateCopyrightCardPosition, 200);
    // ============================================
    // APPLICATION STATE MANAGEMENT
    // ============================================
    
    // Application state object to encapsulate all variables
    const AppState = {
      questions: [],
      originalData: null,
      score: 0,
      explanationMode: 1,
      database: null,
      lastFilteredQuestions: null,
      lastExplanationMode: 1,
      questionResults: [], // Track correct/incorrect for each question
      
      // Test behavior options (defaults)
      allowTryAgain: true,
      showTopicSubtopic: true,
      showImmediateResult: true,
      showCorrectAnswer: true,
      
      // Saved option states for persistence
      savedJsonOptions: null,
      savedDbOptions: null,
      
      // Reset all state variables
      reset() {
        this.questions = [];
        this.originalData = null;
        this.score = 0;
        this.explanationMode = 1;
        this.database = null;
        this.lastFilteredQuestions = null;
        this.lastExplanationMode = 1;
        this.lastDbQueryParams = null;
        this.isDbMode = false;
        this.dbTotalQuestions = 0;
        this.dbTopics = null;
        this.dbTypes = null;
        this.dbFileName = null;
        this.questionResults = []; // Reset question results tracking
        
        // Reset behavior options to defaults
        this.allowTryAgain = true;
        this.showTopicSubtopic = true;
        this.showImmediateResult = true;
        this.showCorrectAnswer = true;
        
        // Clear persistent saved settings
        this.savedJsonOptions = null;
        this.savedDbOptions = null;
      }
    };

    // ============================================
    // OPTION STATE PERSISTENCE
    // ============================================
    
    // Save current options state
    function saveOptionsState() {
      // Auto-detect mode based on the presence of DB-specific elements
      const isDbMode = !!document.getElementById('select-all-topics-db') || AppState.isDbMode;
      
      const state = {
        selectedTopics: [],
        selectedSubtopics: [],
        selectedTypes: [],
        explanationMode: 1,
        behaviorOptions: {
          allowTryAgain: true,
          showTopicSubtopic: true,
          showImmediateResult: true,
          showCorrectAnswer: true
        },
        numQuestions: 10,
        selectionMode: 'random' // Only for DB mode
      };
      
      // Get current form values
      const panel = document.getElementById("filter-panel");
      if (!panel) return;
      
      // Save topic/subtopic selections
      const selectAllTopics = panel.querySelector(isDbMode ? '#select-all-topics-db' : '#select-all-topics');
      if (selectAllTopics) {
        state.allTopicsSelected = selectAllTopics.checked;
      }
      
      // Always save individual selections for fallback
      const topicCheckboxes = panel.querySelectorAll('.topic-checkbox');
      topicCheckboxes.forEach(cb => {
        if (cb.checked) state.selectedTopics.push(cb.value);
      });
      
      const subtopicCheckboxes = panel.querySelectorAll('.subtopic-checkbox');
      subtopicCheckboxes.forEach(cb => {
        if (cb.checked) {
          state.selectedSubtopics.push({
            topic: cb.dataset.topic,
            subtopic: cb.value
          });
        }
      });
      
      // Save type selections - look in the type section specifically
      const typeSection = panel.querySelector('.filter-section h3');
      let typeSectionDiv = null;
      const allSections = panel.querySelectorAll('.filter-section');
      for (let section of allSections) {
        const h3 = section.querySelector('h3');
        if (h3 && h3.textContent.includes('Question Types')) {
          typeSectionDiv = section;
          break;
        }
      }
      
      if (typeSectionDiv) {
        const typeCheckboxes = typeSectionDiv.querySelectorAll('input[type="checkbox"]');
        const allTypesCheckbox = Array.from(typeCheckboxes).find(cb => cb.value === 'ALL');
        if (allTypesCheckbox) {
          state.allTypesSelected = allTypesCheckbox.checked;
        }
        
        // Save individual type selections
        typeCheckboxes.forEach(cb => {
          if (cb.checked && cb.value !== 'ALL') {
            state.selectedTypes.push(cb.value);
          }
        });
      }
      
      // Save explanation mode
      const expRadio = panel.querySelector('input[name="expMode"]:checked');
      if (expRadio) {
        state.explanationMode = parseInt(expRadio.value);
      }
      
      // Save behavior options
      const tryAgainId = isDbMode ? 'tryAgainOptionDb' : 'tryAgainOption';
      const topicRevealId = isDbMode ? 'topicRevealOptionDb' : 'topicRevealOption';
      const immediateResultId = isDbMode ? 'immediateResultOptionDb' : 'immediateResultOption';
      const correctAnswerId = isDbMode ? 'correctAnswerOptionDb' : 'correctAnswerOption';
      
      const tryAgainCb = document.getElementById(tryAgainId);
      const topicRevealCb = document.getElementById(topicRevealId);
      const immediateResultCb = document.getElementById(immediateResultId);
      const correctAnswerCb = document.getElementById(correctAnswerId);
      
      if (tryAgainCb) state.behaviorOptions.allowTryAgain = tryAgainCb.checked;
      if (topicRevealCb) state.behaviorOptions.showTopicSubtopic = topicRevealCb.checked;
      if (immediateResultCb) state.behaviorOptions.showImmediateResult = immediateResultCb.checked;
      if (correctAnswerCb) state.behaviorOptions.showCorrectAnswer = correctAnswerCb.checked;
      
      // Save number of questions
      const numInput = document.getElementById('numQuestions');
      if (numInput) {
        state.numQuestions = parseInt(numInput.value) || 10;
      }
      
      // Save selection mode (DB only)
      if (isDbMode) {
        const selectionModeRadio = panel.querySelector('input[name="selectionMode"]:checked');
        if (selectionModeRadio) {
          state.selectionMode = selectionModeRadio.value;
        }
      }
      
      // Store the state
      if (isDbMode) {
        AppState.savedDbOptions = state;
      } else {
        AppState.savedJsonOptions = state;
      }
      
      console.log(`Saved ${isDbMode ? 'DB' : 'JSON'} options state:`, state);
    }
    
    // Restore options state
    function restoreOptionsState() {
      // Auto-detect mode based on the presence of DB-specific elements
      const isDbMode = !!document.getElementById('select-all-topics-db') || AppState.isDbMode;
      const state = isDbMode ? AppState.savedDbOptions : AppState.savedJsonOptions;
      
      if (!state) {
        console.log(`No saved ${isDbMode ? 'DB' : 'JSON'} options to restore`);
        return false;
      }
      
      console.log(`Restoring ${isDbMode ? 'DB' : 'JSON'} options state:`, state);
      
      // Wait for DOM to be ready
      setTimeout(() => {
        const panel = document.getElementById("filter-panel");
        if (!panel) return;
        
        // Restore topic/subtopic selections
        if (state.allTopicsSelected !== undefined && state.allTopicsSelected) {
          // If "All Topics" was selected, just check that and let it handle the rest
          const selectAllTopics = panel.querySelector(isDbMode ? '#select-all-topics-db' : '#select-all-topics');
          if (selectAllTopics) {
            selectAllTopics.checked = true;
            // Trigger change event to update child checkboxes
            selectAllTopics.dispatchEvent(new Event('change'));
          }
        } else if (state.selectedSubtopics && state.selectedSubtopics.length > 0) {
          // Restore individual subtopic selections
          const selectAllTopics = panel.querySelector(isDbMode ? '#select-all-topics-db' : '#select-all-topics');
          if (selectAllTopics) {
            selectAllTopics.checked = false; // Uncheck "All Topics" first
          }
          
          // Uncheck all first
          const allCheckboxes = panel.querySelectorAll('.topic-checkbox, .subtopic-checkbox');
          allCheckboxes.forEach(cb => cb.checked = false);
          
          // Then check only the saved selections
          const subtopicCheckboxes = panel.querySelectorAll('.subtopic-checkbox');
          subtopicCheckboxes.forEach(cb => {
            const isSelected = state.selectedSubtopics.some(s => 
              s.topic === cb.dataset.topic && s.subtopic === cb.value
            );
            if (isSelected) {
              cb.checked = true;
            }
          });
          
          // Update parent topic checkboxes based on subtopic states
          const topicCheckboxes = panel.querySelectorAll('.topic-checkbox');
          topicCheckboxes.forEach(topicCb => {
            const topic = topicCb.value;
            const relatedSubtopics = panel.querySelectorAll(`.subtopic-checkbox[data-topic="${topic}"]`);
            const checkedSubtopics = Array.from(relatedSubtopics).filter(cb => cb.checked);
            
            if (checkedSubtopics.length === relatedSubtopics.length) {
              topicCb.checked = true;
              topicCb.indeterminate = false;
            } else if (checkedSubtopics.length > 0) {
              topicCb.checked = false;
              topicCb.indeterminate = true;
            } else {
              topicCb.checked = false;
              topicCb.indeterminate = false;
            }
          });
        }
        
        // Restore type selections - find the type section specifically
        const typeSections = panel.querySelectorAll('.filter-section');
        let typeSectionDiv = null;
        for (let section of typeSections) {
          const h3 = section.querySelector('h3');
          if (h3 && h3.textContent.includes('Question Types')) {
            typeSectionDiv = section;
            break;
          }
        }
        
        if (typeSectionDiv) {
          if (state.allTypesSelected !== undefined && state.allTypesSelected) {
            const allTypesCheckbox = typeSectionDiv.querySelector('input[value="ALL"]');
            if (allTypesCheckbox) {
              allTypesCheckbox.checked = true;
              // Trigger change event
              allTypesCheckbox.dispatchEvent(new Event('change'));
            }
          } else if (state.selectedTypes && state.selectedTypes.length > 0) {
            // Restore individual type selections
            const typeCheckboxes = typeSectionDiv.querySelectorAll('input[type="checkbox"]');
            typeCheckboxes.forEach(cb => {
              if (cb.value === 'ALL') {
                cb.checked = false; // Uncheck "All" if individual selections exist
              } else {
                cb.checked = state.selectedTypes.includes(cb.value);
              }
            });
          }
        }
        
        // Restore explanation mode
        const expRadios = panel.querySelectorAll('input[name="expMode"]');
        expRadios.forEach(radio => {
          radio.checked = (parseInt(radio.value) === state.explanationMode);
        });
        
        // Restore behavior options
        const tryAgainId = isDbMode ? 'tryAgainOptionDb' : 'tryAgainOption';
        const topicRevealId = isDbMode ? 'topicRevealOptionDb' : 'topicRevealOption';
        const immediateResultId = isDbMode ? 'immediateResultOptionDb' : 'immediateResultOption';
        const correctAnswerId = isDbMode ? 'correctAnswerOptionDb' : 'correctAnswerOption';
        
        const tryAgainCb = document.getElementById(tryAgainId);
        const topicRevealCb = document.getElementById(topicRevealId);
        const immediateResultCb = document.getElementById(immediateResultId);
        const correctAnswerCb = document.getElementById(correctAnswerId);
        
        if (tryAgainCb) tryAgainCb.checked = state.behaviorOptions.allowTryAgain;
        if (topicRevealCb) topicRevealCb.checked = state.behaviorOptions.showTopicSubtopic;
        if (immediateResultCb) {
          immediateResultCb.checked = state.behaviorOptions.showImmediateResult;
          // Trigger change event to update dependent options
          immediateResultCb.dispatchEvent(new Event('change'));
        }
        if (correctAnswerCb) correctAnswerCb.checked = state.behaviorOptions.showCorrectAnswer;
        
        // Restore number of questions
        const numInput = document.getElementById('numQuestions');
        if (numInput && state.numQuestions) {
          numInput.value = state.numQuestions;
          // Force update to override any automatic updates
          setTimeout(() => {
            numInput.value = state.numQuestions;
          }, 50);
        }
        
        // Restore selection mode (DB only)
        if (isDbMode && state.selectionMode) {
          const selectionModeRadios = panel.querySelectorAll('input[name="selectionMode"]');
          selectionModeRadios.forEach(radio => {
            radio.checked = (radio.value === state.selectionMode);
          });
        }
      }, 10); // Minimal timeout to ensure DOM is ready
      
      return true;
    }

    // Set copyright year in footer
    (function initializeCopyright() {
      const copyrightYearElement = document.getElementById('swamys-copyright-year');
      if (copyrightYearElement) {
        copyrightYearElement.textContent = new Date().getFullYear();
      }
    })();

    function resetWorkflow() {
      // Close database connection if it exists
      if (AppState.database) {
        try {
          AppState.database.close();
          console.log("Database connection closed");
        } catch (error) {
          console.warn("Error closing database connection:", error);
        }
      }
      
      // Clear all state
      AppState.reset();
      
      // Remove event listeners to prevent memory leaks
      removeAllEventListeners();

      // Clear DOM safely
      clearElement(document.getElementById("test"));
      clearElement(document.getElementById("scoreboard"));
      clearElement(document.getElementById("filter-panel"));
      
      document.getElementById("restart").style.display = "none";
      document.getElementById("restart-bottom").style.display = "none";
      document.getElementById("newtest").style.display = "none";
      
      // Hide all extra buttons on start page (only show Choose JSON and Choose DB)
      const backToStartButton = document.getElementById("backToStartFromOptions");
      const backToOptionsButton = document.getElementById("backToOptions");
      const newQuestionsButton = document.getElementById("newTestSameOptions");
      
      if (backToStartButton) {
        backToStartButton.style.display = "none";
      }
      if (backToOptionsButton) {
        backToOptionsButton.style.display = "none";
      }
      if (newQuestionsButton) {
        newQuestionsButton.style.display = "none";
      }
      
      setTextContent(document.getElementById("file-chosen"), "");
      
      // Show file selection buttons again on start page
      const chooseJsonLabel = document.querySelector('label[for="fileInput"]');
      const chooseDbButton = document.getElementById("chooseDb");
      if (chooseJsonLabel) {
        chooseJsonLabel.style.display = "inline-block";
      }
      if (chooseDbButton) {
        chooseDbButton.style.display = "inline-block";
      }
      
      // Show the how-to-use guide when resetting
      const guideElement = document.getElementById("how-to-use-guide");
      if (guideElement) {
        guideElement.style.display = "block";
      }
    }

    // ============================================
    // SECURE DATABASE OPERATIONS
    // ============================================
    
    // Secure SQL query execution with parameter binding
    function executeSecureQuery(database, query, params = []) {
      try {
        const stmt = database.prepare(query);
        const result = stmt.getAsObject(params);
        stmt.free();
        return result;
      } catch (error) {
        console.error('Database query error:', error);
        throw new Error('Database operation failed');
      }
    }
    
    // Secure query for multiple results
    function executeSecureQueryAll(database, query, params = []) {
      try {
        const stmt = database.prepare(query);
        const results = [];
        stmt.bind(params);
        while (stmt.step()) {
          results.push(stmt.getAsObject());
        }
        stmt.free();
        return results;
      } catch (error) {
        console.error('Database query error:', error);
        throw new Error('Database operation failed');
      }
    }
    
    // Escape and validate string inputs for SQL
    function escapeSQL(value) {
      if (typeof value !== 'string') return value;
      return value.replace(/'/g, "''");
    }
    
    // Validate database inputs
    function validateDatabaseInput(input, allowedValues = null) {
      if (allowedValues && !allowedValues.includes(input)) {
        throw new Error('Invalid database input');
      }
      return escapeSQL(input);
    }

    // ============================================
    // MEMORY MANAGEMENT & CLEANUP
    // ============================================
    
    // Store event listeners for proper cleanup
    const eventListeners = new WeakMap();
    
    function addEventListenerWithCleanup(element, event, handler, options) {
      element.addEventListener(event, handler, options);
      
      if (!eventListeners.has(element)) {
        eventListeners.set(element, []);
      }
      eventListeners.get(element).push({ event, handler, options });
    }
    
    function removeAllEventListeners() {
      // This would be called when resetting the workflow
      // In practice, removing DOM elements automatically removes their listeners
      // but this structure allows for manual cleanup if needed
      document.querySelectorAll('.question-card').forEach(card => {
        card.remove(); // This removes all associated event listeners
      });
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // ============================================
    // HTML SANITIZATION & DOM UTILITIES
    // ============================================
    
    // Sanitize text content to prevent XSS attacks
    function sanitizeText(text) {
      if (typeof text !== 'string') return '';
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;');
    }
    
    // Safe way to set text content (no HTML injection)
    function setTextContent(element, text) {
      element.textContent = text || '';
    }
    
    // Safe way to create elements with text content
    function createElement(tagName, textContent = '', className = '') {
      const element = document.createElement(tagName);
      if (textContent) setTextContent(element, textContent);
      if (className) element.className = className;
      return element;
    }
    
    // Efficient DOM updates using DocumentFragment
    function appendMultipleElements(parent, elements) {
      const fragment = document.createDocumentFragment();
      elements.forEach(element => fragment.appendChild(element));
      parent.appendChild(fragment);
    }
    
    // Clear element content safely
    function clearElement(element) {
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }

    // ============================================
    // REUSABLE MATCH QUESTION RENDERER
    // ============================================
    function createMatchQuestion(question, questionDiv, questionIndex) {
      const keys = Object.keys(question.matchPairs);
      const values = shuffle(Object.values(question.matchPairs));
      
      const table = createElement("div", "", "match-table");
      const selects = [];
      
      keys.forEach(key => {
        const row = createElement("div", "", "match-row");
        const leftCell = createElement("div", key, "match-cell");
        const rightCell = createElement("div", "", "match-cell");
        
        const select = document.createElement("select");
        
        // Add placeholder option
        const placeholder = document.createElement("option");
        placeholder.value = "";
        setTextContent(placeholder, "<Select One>");
        placeholder.disabled = true;
        placeholder.selected = true;
        select.appendChild(placeholder);
        
        // Add value options
        values.forEach(value => {
          const option = document.createElement("option");
          option.value = value;
          setTextContent(option, value);
          select.appendChild(option);
        });
        
        rightCell.appendChild(select);
        appendMultipleElements(row, [leftCell, rightCell]);
        table.appendChild(row);
        
        selects.push(select);
      });
      
      questionDiv.appendChild(table);
      
      // Create submit button
      const submitBtn = createElement("button", "Submit Matches");
      submitBtn.title = "Submit your selected matches for this question. Match each item on the left to the correct option on the right.";
      submitBtn.disabled = true;
      
      // Enable submit button when all selections are made
      selects.forEach(select => {
        select.addEventListener("change", function handleSelectChange() {
          const allFilled = selects.every(s => s.value !== "");
          submitBtn.disabled = !allFilled;
        });
      });
      
      // Handle submit
      submitBtn.addEventListener("click", function handleMatchSubmit() {
        const userMatches = {};
        keys.forEach((key, index) => {
          userMatches[key] = selects[index].value;
        });
        handleAnswer(question, userMatches, questionDiv, questionIndex);
      });
      
      questionDiv.appendChild(submitBtn);
    }

    // Utility function to reset options to defaults after loading new data source
    function resetOptionsToDefaults() {
      // Clear persistent saved settings to prevent restoration
      AppState.savedJsonOptions = null;
      AppState.savedDbOptions = null;
      
      // Reset AppState to default values
      AppState.allowTryAgain = true;
      AppState.showTopicSubtopic = true;
      AppState.showImmediateResult = true;
      AppState.showCorrectAnswer = true;
      AppState.explanationMode = 1; // "Both when right and wrong"
      
      console.log("Reset all options to defaults after loading new data source");
    }

    document.getElementById("fileInput").addEventListener("change", function(e) {
      const file = e.target.files[0];
      if (!file) return;

      // If a test is already loaded, reset workflow instead of reload
      if (AppState.originalData !== null || AppState.questions.length > 0) {
        resetWorkflow();
      }
      
      // Don't hide the guide here - let buildFilterPanel handle it
      
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const data = JSON.parse(event.target.result);
          AppState.originalData = data;
          AppState.isDbMode = false; // Set JSON mode flag
          document.getElementById("file-chosen").innerHTML =
            `✅ Test loaded: <strong>${data.title || file.name}</strong>`;
          
          // Reset options to defaults after successful JSON loading
          resetOptionsToDefaults();
          
          buildFilterPanel(data.questions);
        } catch (err) {
          alert("Invalid JSON file.");
          // Keep guide visible if file loading failed
        }
      };
      reader.readAsText(file);
      e.target.value = ""; // allow re-selecting the same file again
    });

    function setupAllCheckbox(sectionDiv) {
      const checkboxes = sectionDiv.querySelectorAll("input[type=checkbox]");
      const allBox = checkboxes[0];
      const children = Array.from(checkboxes).slice(1);

      allBox.addEventListener("change", () => {
        children.forEach(cb => cb.checked = allBox.checked);
      });

      children.forEach(cb => {
        cb.addEventListener("change", () => {
          if (children.every(c => c.checked)) {
            allBox.checked = true;
          } else {
            allBox.checked = false;
          }
        });
      });
    }

    function setupTopicSubtopicCheckboxes(topicDiv) {
      const selectAllCheckbox = topicDiv.querySelector('#select-all-topics');
      const topicCheckboxes = topicDiv.querySelectorAll('.topic-checkbox');
      const subtopicCheckboxes = topicDiv.querySelectorAll('.subtopic-checkbox');

      // Select All functionality
      selectAllCheckbox.addEventListener('change', () => {
        const isChecked = selectAllCheckbox.checked;
        topicCheckboxes.forEach(cb => cb.checked = isChecked);
        subtopicCheckboxes.forEach(cb => cb.checked = isChecked);
      });

      // Topic checkbox functionality
      topicCheckboxes.forEach(topicCb => {
        const topic = topicCb.value;
        const relatedSubtopics = topicDiv.querySelectorAll(`.subtopic-checkbox[data-topic="${topic}"]`);
        
        topicCb.addEventListener('change', () => {
          const isChecked = topicCb.checked;
          relatedSubtopics.forEach(subtopicCb => subtopicCb.checked = isChecked);
          updateSelectAllState();
        });
      });

      // Subtopic checkbox functionality  
      subtopicCheckboxes.forEach(subtopicCb => {
        subtopicCb.addEventListener('change', () => {
          const topic = subtopicCb.dataset.topic;
          const topicCheckbox = topicDiv.querySelector(`.topic-checkbox[value="${topic}"]`);
          const relatedSubtopics = topicDiv.querySelectorAll(`.subtopic-checkbox[data-topic="${topic}"]`);
          
          // Update parent topic checkbox based on subtopic states
          const allSubtopicsChecked = Array.from(relatedSubtopics).every(cb => cb.checked);
          const anySubtopicChecked = Array.from(relatedSubtopics).some(cb => cb.checked);
          
          topicCheckbox.checked = allSubtopicsChecked;
          topicCheckbox.indeterminate = anySubtopicChecked && !allSubtopicsChecked;
          
          updateSelectAllState();
        });
      });

      function updateSelectAllState() {
        const allTopicsChecked = Array.from(topicCheckboxes).every(cb => cb.checked);
        const anyTopicChecked = Array.from(topicCheckboxes).some(cb => cb.checked);
        
        selectAllCheckbox.checked = allTopicsChecked;
        selectAllCheckbox.indeterminate = anyTopicChecked && !allTopicsChecked;
      }
    }

    // Database-specific setup function for hierarchical checkboxes
    function setupTopicSubtopicCheckboxesDb(topicDiv, updateMaxQuestions) {
      const selectAllCheckbox = topicDiv.querySelector('#select-all-topics-db');
      const topicCheckboxes = topicDiv.querySelectorAll('.topic-checkbox');
      const subtopicCheckboxes = topicDiv.querySelectorAll('.subtopic-checkbox');

      // Select All functionality
      selectAllCheckbox.addEventListener('change', () => {
        const isChecked = selectAllCheckbox.checked;
        topicCheckboxes.forEach(cb => cb.checked = isChecked);
        subtopicCheckboxes.forEach(cb => cb.checked = isChecked);
        // Trigger update when select all changes
        if (typeof updateMaxQuestions === 'function') updateMaxQuestions();
      });

      // Topic checkbox functionality
      topicCheckboxes.forEach(topicCb => {
        const topic = topicCb.value;
        const relatedSubtopics = topicDiv.querySelectorAll(`.subtopic-checkbox[data-topic="${topic}"]`);
        
        topicCb.addEventListener('change', () => {
          const isChecked = topicCb.checked;
          relatedSubtopics.forEach(subtopicCb => subtopicCb.checked = isChecked);
          updateSelectAllState();
          // Trigger update when topic changes
          if (typeof updateMaxQuestions === 'function') updateMaxQuestions();
        });
      });

      // Subtopic checkbox functionality  
      subtopicCheckboxes.forEach(subtopicCb => {
        subtopicCb.addEventListener('change', () => {
          const topic = subtopicCb.dataset.topic;
          const topicCheckbox = topicDiv.querySelector(`.topic-checkbox[value="${topic}"]`);
          const relatedSubtopics = topicDiv.querySelectorAll(`.subtopic-checkbox[data-topic="${topic}"]`);
          
          // Update parent topic checkbox based on subtopic states
          const allSubtopicsChecked = Array.from(relatedSubtopics).every(cb => cb.checked);
          const anySubtopicChecked = Array.from(relatedSubtopics).some(cb => cb.checked);
          
          topicCheckbox.checked = allSubtopicsChecked;
          topicCheckbox.indeterminate = anySubtopicChecked && !allSubtopicsChecked;
          
          updateSelectAllState();
          // Trigger update when subtopic changes
          if (typeof updateMaxQuestions === 'function') updateMaxQuestions();
        });
      });

      function updateSelectAllState() {
        const allTopicsChecked = Array.from(topicCheckboxes).every(cb => cb.checked);
        const anyTopicChecked = Array.from(topicCheckboxes).some(cb => cb.checked);
        
        selectAllCheckbox.checked = allTopicsChecked;
        selectAllCheckbox.indeterminate = anyTopicChecked && !allTopicsChecked;
      }
    }

    // Helper function to get selected topic/subtopic combinations
    function getSelectedTopicSubtopics(topicDiv) {
      const selectedCombinations = [];
      const subtopicCheckboxes = topicDiv.querySelectorAll('.subtopic-checkbox:checked');
      
      subtopicCheckboxes.forEach(cb => {
        selectedCombinations.push({
          topic: cb.dataset.topic,
          subtopic: cb.value
        });
      });
      
      return selectedCombinations;
    }

    // Helper function to check if a question matches selected topic/subtopic criteria
    function questionMatchesTopicSubtopicSelection(question, selectedCombinations) {
      return selectedCombinations.some(combo => {
        const questionSubtopic = question.subtopic || 'General';
        return question.topic === combo.topic && questionSubtopic === combo.subtopic;
      });
    }

    function buildFilterPanel(allQuestions, skipRestore = false) {
      const panel = document.getElementById("filter-panel");
      panel.innerHTML = "";

      // Hide the how-to-use guide when options page loads
      const guideElement = document.getElementById("how-to-use-guide");
      if (guideElement) {
        guideElement.style.display = "none";
      }

      // Show the Back to Start Page button when in options
      const backToStartButton = document.getElementById("backToStartFromOptions");
      if (backToStartButton) {
        backToStartButton.style.display = "inline-block";
      }

      // Hide extra buttons during options mode (only show Choose JSON, Choose DB, Back to Start Page)
      const backToOptionsButton = document.getElementById("backToOptions");
      const newQuestionsButton = document.getElementById("newTestSameOptions");
      if (backToOptionsButton) {
        backToOptionsButton.style.display = "none";
      }
      if (newQuestionsButton) {
        newQuestionsButton.style.display = "none";
      }

      // Show file selection buttons during options
      const chooseJsonLabel = document.querySelector('label[for="fileInput"]');
      const chooseDbButton = document.getElementById("chooseDb");
      if (chooseJsonLabel) {
        chooseJsonLabel.style.display = "inline-block";
      }
      if (chooseDbButton) {
        chooseDbButton.style.display = "inline-block";
      }

      // Debug: Log the first few questions to see their structure
      console.log("Sample questions for debugging:", allQuestions.slice(0, 3));

      // Build hierarchical topic-subtopic structure
      const topicSubtopicMap = new Map();
      allQuestions.forEach(q => {
        const topic = q.topic;
        const subtopic = q.subtopic || 'General'; // Use actual subtopic field from data
        
        if (!topicSubtopicMap.has(topic)) {
          topicSubtopicMap.set(topic, new Set());
        }
        topicSubtopicMap.get(topic).add(subtopic);
      });

      // Debug: Log the topic-subtopic mapping
      console.log("Topic-Subtopic Map:", topicSubtopicMap);

      const types = [...new Set(allQuestions.map(q => q.type))];

      const wrapper = document.createElement("div");
      wrapper.className = "filter-panel";

      // Topics with nested subtopics
      const topicDiv = document.createElement("div");
      topicDiv.className = "filter-section";
      topicDiv.innerHTML = "<h3>Select Topics & Subtopics</h3>";
      
      // Select All checkbox
      const selectAllDiv = document.createElement("div");
      selectAllDiv.style.marginBottom = "15px";
      selectAllDiv.style.borderBottom = "1px solid #ddd";
      selectAllDiv.style.paddingBottom = "10px";
      const selectAllLabel = document.createElement("label");
      selectAllLabel.style.fontWeight = "bold";
      selectAllLabel.innerHTML = `<input type="checkbox" id="select-all-topics" checked> Select All Topics & Subtopics`;
      selectAllDiv.appendChild(selectAllLabel);
      topicDiv.appendChild(selectAllDiv);

      // Create hierarchical structure
      const topicContainer = document.createElement("div");
      topicContainer.className = "topic-hierarchy";
      
      Array.from(topicSubtopicMap.keys()).sort().forEach(topic => {
        const subtopics = Array.from(topicSubtopicMap.get(topic)).sort();
        
        // Get question count for this topic
        const topicQuestionCount = allQuestions.filter(q => q.topic === topic).length;
        
        // Topic level container
        const topicItemDiv = document.createElement("div");
        topicItemDiv.className = "topic-item";
        topicItemDiv.style.marginBottom = "10px";
        
        // Topic checkbox with question count
        const topicLabel = document.createElement("label");
        topicLabel.style.fontWeight = "bold";
        topicLabel.style.display = "block";
        topicLabel.innerHTML = `<input type="checkbox" class="topic-checkbox" value="${topic}" checked> ${topic} <span style="color: #666; font-weight: normal;">(${topicQuestionCount} question${topicQuestionCount === 1 ? '' : 's'})</span>`;
        topicItemDiv.appendChild(topicLabel);
        
        // Subtopics container
        const subtopicsDiv = document.createElement("div");
        subtopicsDiv.className = "subtopics-container";
        subtopicsDiv.style.marginLeft = "20px";
        subtopicsDiv.style.marginTop = "5px";
        
        subtopics.forEach(subtopic => {
          // Get question count for this specific topic/subtopic combination
          const subtopicQuestionCount = allQuestions.filter(q => q.topic === topic && (q.subtopic || 'General') === subtopic).length;
          
          const subtopicLabel = document.createElement("label");
          subtopicLabel.style.display = "block";
          subtopicLabel.style.fontSize = "0.9em";
          subtopicLabel.style.marginBottom = "2px";
          subtopicLabel.innerHTML = `<input type="checkbox" class="subtopic-checkbox" data-topic="${topic}" value="${subtopic}" checked> ${subtopic} <span style="color: #666;">(${subtopicQuestionCount} question${subtopicQuestionCount === 1 ? '' : 's'})</span>`;
          subtopicsDiv.appendChild(subtopicLabel);
        });
        
        topicItemDiv.appendChild(subtopicsDiv);
        topicContainer.appendChild(topicItemDiv);
      });
      
      topicDiv.appendChild(topicContainer);
      setupTopicSubtopicCheckboxes(topicDiv);

      // Types
      const typeDiv = document.createElement("div");
      typeDiv.className = "filter-section";
      typeDiv.innerHTML = "<h3>Select Question Types</h3>";
      const allTypes = document.createElement("label");
      allTypes.innerHTML = `<input type="checkbox" value="ALL" checked> ALL <span style="color: #666; font-weight: normal;">(${allQuestions.length} question${allQuestions.length === 1 ? '' : 's'})</span>`;
      typeDiv.appendChild(allTypes);
      types.forEach(t => {
        const typeQuestionCount = allQuestions.filter(q => q.type === t).length;
        const l = document.createElement("label");
        l.style.display = "block";
        l.innerHTML = `<input type="checkbox" value="${t}" checked> ${t} <span style="color: #666; font-weight: normal;">(${typeQuestionCount} question${typeQuestionCount === 1 ? '' : 's'})</span>`;
        typeDiv.appendChild(l);
      });
      setupAllCheckbox(typeDiv);

      // Explanation display mode
      const expDiv = document.createElement("div");
      expDiv.className = "filter-section";
      expDiv.innerHTML = "<h3>Explanation & Reference Display</h3>";
      expDiv.innerHTML += `
        <label><input type="radio" name="expMode" value="1" checked> Only when wrong</label><br>
        <label><input type="radio" name="expMode" value="2"> Both when right and wrong</label><br>
        <label><input type="radio" name="expMode" value="3"> Do not display explanations</label>
      `;

      // Test behavior options
      const behaviorDiv = document.createElement("div");
      behaviorDiv.className = "filter-section";
      behaviorDiv.innerHTML = "<h3>Test Behavior Options</h3>";
      behaviorDiv.innerHTML += `
        <label><input type="checkbox" id="tryAgainOption" checked> Allow "Try Again" for incorrect answers</label><br>
        <label><input type="checkbox" id="topicRevealOption" checked> Show Topic/Subtopic when answering</label><br>
        <label><input type="checkbox" id="immediateResultOption" checked> Show result immediately after each answer</label><br>
        <label><input type="checkbox" id="correctAnswerOption" checked> Show correct answer when wrong</label>
        <div style="margin-top: 8px; padding: 8px; background: #f0f8ff; border-radius: 4px; font-size: 0.9em; color: #666;">
          <em>Note: If "immediate result" is OFF, results and selected options will be revealed after the final score</em>
        </div>
      `;

      // Add immediate result option change handler (JSON mode)
      setTimeout(() => {
        const immediateResultCheckbox = document.getElementById("immediateResultOption");
        const correctAnswerCheckbox = document.getElementById("correctAnswerOption");
        const tryAgainCheckbox = document.getElementById("tryAgainOption");
        const explanationRadios = expDiv.querySelectorAll('input[name="expMode"]');
        
        immediateResultCheckbox.addEventListener("change", () => {
          if (!immediateResultCheckbox.checked) {
            // When immediate result is turned OFF, disable "Try Again" (incompatible with delayed results)
            tryAgainCheckbox.checked = false;
            tryAgainCheckbox.disabled = true;
            // Keep other options available for user choice - they'll be applied after final score
          } else {
            // When turned back ON, re-enable "Try Again" and set reasonable defaults
            tryAgainCheckbox.disabled = false;
            if (!correctAnswerCheckbox.checked && !tryAgainCheckbox.checked) {
              // If both were unchecked, set reasonable defaults
              correctAnswerCheckbox.checked = true;
              tryAgainCheckbox.checked = true;
            }
            if (explanationRadios[2].checked) {
              // If explanations were set to "none", change to a reasonable default
              explanationRadios[1].checked = true; // "Both when right and wrong"
            }
          }
        });
      }, 0);

      // Number of questions
      const maxQuestions = allQuestions.length;
      const numDiv = document.createElement("div");
      numDiv.className = "filter-section";
      numDiv.innerHTML = `<h3>Number of Questions</h3><input type=\"number\" id=\"numQuestions\" min=\"1\" value=\"${Math.min(10, maxQuestions)}\" max=\"${maxQuestions}\"> <span style=\"margin-left:10px; color:#0078d7; font-weight:bold;\">Max: ${maxQuestions} question${maxQuestions === 1 ? '' : 's'} available for selection</span>`;

      // Start button
      const startBtn = document.createElement("button");
      startBtn.textContent = "Start Test";
      startBtn.className = "custom-btn";
      
      startBtn.addEventListener("click", () => {
        // Save current options state before starting test
        saveOptionsState();
        
        // JSON mode: filter questions by selected topics/types and shuffle randomly
        const topics = [...new Set(allQuestions.map(q => q.topic))];
        
        let selectedTopics = [];
        let selectedTypes = [];
        const topicChecks = topicDiv.querySelectorAll("input[type=checkbox]");
        if (topicChecks[0].checked) {
          selectedTopics = topics;
        } else {
          topicChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTopics.push(cb.value);
          });
        }
        const typeChecks = typeDiv.querySelectorAll("input[type=checkbox]");
        if (typeChecks[0].checked) {
          selectedTypes = types;
        } else {
          typeChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTypes.push(cb.value);
          });
        }
        
        const expChoice = expDiv.querySelector("input[name=expMode]:checked");
        AppState.explanationMode = parseInt(expChoice.value);
        
        // Capture test behavior options
        AppState.allowTryAgain = document.getElementById("tryAgainOption").checked;
        AppState.showTopicSubtopic = document.getElementById("topicRevealOption").checked;
        AppState.showImmediateResult = document.getElementById("immediateResultOption").checked;
        AppState.showCorrectAnswer = document.getElementById("correctAnswerOption").checked;
        
        // Filter questions based on selection
        let filteredQuestions = allQuestions.filter(q => selectedTopics.includes(q.topic) && selectedTypes.includes(q.type));
        
        const numInput = document.getElementById("numQuestions");
        const maxQuestions = filteredQuestions.length;
        let numQuestions = Math.max(1, Math.min(parseInt(numInput.value) || 10, maxQuestions));
        
        if (numQuestions > maxQuestions) {
          document.getElementById("file-chosen").innerHTML = `<span style='color:red;'>You requested ${numQuestions} questions, but only ${maxQuestions} are available for the selected criteria. Please reduce the number.</span>`;
          return;
        }
        
        // Always use random selection in JSON mode
        filteredQuestions = shuffle(filteredQuestions);
        const chosenQuestions = filteredQuestions.slice(0, numQuestions);
        
        document.getElementById("file-chosen").innerHTML = `Loaded ${chosenQuestions.length} questions. Preparing test UI...`;
        setTimeout(() => {
          panel.innerHTML = "";
          document.getElementById("restart").style.display = "none";
          document.getElementById("restart-bottom").style.display = "none";
          startTest(chosenQuestions);
        }, 500);
      });
      // Dynamic max count update for JSON mode
      function updateMaxQuestionsJSON() {
        // Get selected topic/subtopic combinations (same logic as Start Test button)
        let selectedCombinations = [];
        const selectAllCheckbox = topicDiv.querySelector('#select-all-topics');
        
        if (selectAllCheckbox && selectAllCheckbox.checked) {
          // All topics and subtopics selected
          allQuestions.forEach(q => {
            const topic = q.topic;
            const subtopic = q.subtopic || 'General';
            const combo = { topic, subtopic };
            if (!selectedCombinations.some(c => c.topic === combo.topic && c.subtopic === combo.subtopic)) {
              selectedCombinations.push(combo);
            }
          });
        } else {
          // Get individual subtopic selections
          const subtopicCheckboxes = topicDiv.querySelectorAll('.subtopic-checkbox:checked');
          subtopicCheckboxes.forEach(cb => {
            selectedCombinations.push({
              topic: cb.dataset.topic,
              subtopic: cb.value
            });
          });
        }
        
        // Get selected types
        let selectedTypes = [];
        const typeChecks = typeDiv.querySelectorAll("input[type=checkbox]");
        if (typeChecks[0].checked) {
          selectedTypes = types;
        } else {
          typeChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTypes.push(cb.value);
          });
        }
        
        // Filter questions based on selected topic/subtopic combinations and types
        const filteredQuestions = allQuestions.filter(q => {
          const questionSubtopic = q.subtopic || 'General';
          const matchesTopicSubtopic = selectedCombinations.some(combo => 
            q.topic === combo.topic && questionSubtopic === combo.subtopic
          );
          const matchesType = selectedTypes.includes(q.type);
          return matchesTopicSubtopic && matchesType;
        });
        
        const maxQuestions = filteredQuestions.length;
        const numInput = document.getElementById("numQuestions");
        numInput.max = maxQuestions;
        
        // Only auto-adjust if the current value is invalid, otherwise preserve user input
        const currentValue = parseInt(numInput.value) || 0;
        if (currentValue < 1) {
          numInput.value = Math.min(10, maxQuestions);
        } else if (currentValue > maxQuestions) {
          numInput.value = maxQuestions;
        }
        
        // Update max info
        const maxInfo = numDiv.querySelector("span");
        if (maxInfo) maxInfo.textContent = `Max: ${maxQuestions} question${maxQuestions === 1 ? '' : 's'} available for selection`;
        startBtn.disabled = (maxQuestions < 1 || parseInt(numInput.value) < 1 || parseInt(numInput.value) > maxQuestions);
      }
      topicDiv.addEventListener("change", updateMaxQuestionsJSON);
      typeDiv.addEventListener("change", updateMaxQuestionsJSON);
      setTimeout(() => {
        const numInput = document.getElementById("numQuestions");
        if (numInput) numInput.addEventListener("input", updateMaxQuestionsJSON);
        updateMaxQuestionsJSON();
      }, 0);
      
      // Create button container for Start Test button
      const buttonContainer = document.createElement("div");
      buttonContainer.style.marginTop = "20px";
      buttonContainer.style.textAlign = "center";
      
      // Create Reset to Defaults button
      const resetBtn = document.createElement("button");
      resetBtn.textContent = "Reset to Defaults";
      resetBtn.className = "custom-btn";
      resetBtn.style.marginRight = "10px";
      resetBtn.style.backgroundColor = "#f5f5f5";
      resetBtn.style.color = "#333";
      resetBtn.style.border = "1px solid #ccc";
      
      resetBtn.addEventListener("click", () => {
        // Reset all selections to defaults
        
        // Reset topics - check "All Topics"
        const topicChecks = topicDiv.querySelectorAll("input[type=checkbox]");
        topicChecks.forEach((cb, i) => {
          cb.checked = i === 0; // Only check "All Topics"
        });
        
        // Reset types - check "All Types"
        const typeChecks = typeDiv.querySelectorAll("input[type=checkbox]");
        typeChecks.forEach((cb, i) => {
          cb.checked = i === 0; // Only check "All Types"
        });
        
        // Reset explanation mode to "Both when right and wrong" (value 1)
        const expRadios = expDiv.querySelectorAll("input[name=expMode]");
        expRadios.forEach(radio => {
          radio.checked = radio.value === "1";
        });
        
        // Reset behavior options to defaults
        document.getElementById("tryAgainOption").checked = true;
        document.getElementById("topicRevealOption").checked = true;
        document.getElementById("immediateResultOption").checked = true;
        document.getElementById("correctAnswerOption").checked = true;
        
        // Update AppState with default values
        AppState.allowTryAgain = true;
        AppState.showTopicSubtopic = true;
        AppState.showImmediateResult = true;
        AppState.showCorrectAnswer = true;
        AppState.explanationMode = 1; // "Only when wrong"
        
        // Clear persistent saved settings to prevent restoration
        AppState.savedJsonOptions = null;
        
        // Update immediate result option state (trigger change event to apply DOM logic)
        document.getElementById("immediateResultOption").dispatchEvent(new Event('change'));
        
        // Reset number of questions to default (10 or max available)
        const maxQuestions = allQuestions.length;
        document.getElementById("numQuestions").value = Math.min(10, maxQuestions);
        
        console.log("Reset all options to defaults");
      });
      
      buttonContainer.appendChild(resetBtn);
      buttonContainer.appendChild(startBtn);
      
      wrapper.appendChild(topicDiv);
      wrapper.appendChild(typeDiv);
      wrapper.appendChild(expDiv);
      wrapper.appendChild(behaviorDiv);
      wrapper.appendChild(numDiv);
      wrapper.appendChild(buttonContainer);
      panel.appendChild(wrapper);
      
      // Restore previously saved options state after all event listeners are set up
      if (!skipRestore) {
        setTimeout(() => {
          restoreOptionsState();
        }, 100);
      }
    }

    document.getElementById("chooseDb").addEventListener("click", async () => {
      // Prompt user to select the SQLite DB file
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".db";
      input.style.display = "none";
      document.body.appendChild(input);
      input.click();
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) {
          // Keep guide visible if no file was selected
          return;
        }
        
        // Clear all DOMs and reset state only after file is selected
        document.getElementById("test").innerHTML = "";
        document.getElementById("scoreboard").innerHTML = "";
        document.getElementById("restart").style.display = "none";
        document.getElementById("restart-bottom").style.display = "none";
        document.getElementById("newtest").style.display = "none";
        document.getElementById("file-chosen").innerHTML = "";
        document.getElementById("filter-panel").innerHTML = "";
        
        // Don't hide the guide here - let buildDbFilterPanel handle it
        
        // Store the database filename
        AppState.dbFileName = file.name;
        
        document.getElementById("file-chosen").innerHTML = "Loading database file...";
        try {
          const arrayBuffer = await file.arrayBuffer();
          const SQL = await initSqlJs({ locateFile: fileName => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${fileName}` });
          AppState.database = new SQL.Database(new Uint8Array(arrayBuffer));
          AppState.isDbMode = true; // Set database mode flag
          document.getElementById("file-chosen").innerHTML = "Database loaded. Fetching topics and question types...";
          // Fetch topics and types
          const topicsRes = AppState.database.exec("SELECT DISTINCT topic FROM questions");
          const typesRes = AppState.database.exec("SELECT DISTINCT question_type FROM questions");
          const countRes = AppState.database.exec("SELECT COUNT(*) FROM questions");
          const totalQuestions = countRes[0]?.values[0][0] || 0;
          const topics = topicsRes[0]?.values.map(v => v[0]) || [];
          const types = (typesRes[0]?.values.map(v => v[0]) || []).filter(type => type !== 'Cohort-05-Match');
          
          // Store for later use when going back to options
          AppState.dbTopics = topics;
          AppState.dbTypes = types;
          
          if (topics.length === 0 || types.length === 0) {
            document.getElementById("file-chosen").innerHTML = "No topics or question types found in the database.";
            return;
          }
          document.getElementById("file-chosen").innerHTML = `Database ready. Total questions: <strong>${totalQuestions}</strong>. Please select filters and number of questions.`;
          
          // Reset options to defaults after successful database loading
          resetOptionsToDefaults();
          
          buildDbFilterPanel(topics, types);
        } catch (err) {
          document.getElementById("file-chosen").innerHTML = "Error loading database: " + err.message;
        }
        document.body.removeChild(input);
      };
    });

    // Event listener for Back to Start Page button (shown only in options)
    document.getElementById("backToStartFromOptions").addEventListener("click", () => {
      resetWorkflow();
    });

    function buildDbFilterPanel(topics, types, skipRestore = false) {
      const panel = document.getElementById("filter-panel");
      panel.innerHTML = "";
      
      // Hide the how-to-use guide when options page loads
      const guideElement = document.getElementById("how-to-use-guide");
      if (guideElement) {
        guideElement.style.display = "none";
      }
      
      // Show the Back to Start Page button when in options
      const backToStartButton = document.getElementById("backToStartFromOptions");
      if (backToStartButton) {
        backToStartButton.style.display = "inline-block";
      }

      // Hide extra buttons during options mode (only show Choose JSON, Choose DB, Back to Start Page)
      const backToOptionsButton = document.getElementById("backToOptions");
      const newQuestionsButton = document.getElementById("newTestSameOptions");
      if (backToOptionsButton) {
        backToOptionsButton.style.display = "none";
      }
      if (newQuestionsButton) {
        newQuestionsButton.style.display = "none";
      }

      // Show file selection buttons during options
      const chooseJsonLabel = document.querySelector('label[for="fileInput"]');
      const chooseDbButton = document.getElementById("chooseDb");
      if (chooseJsonLabel) {
        chooseJsonLabel.style.display = "inline-block";
      }
      if (chooseDbButton) {
        chooseDbButton.style.display = "inline-block";
      }
      
      // First, we need to get the topic-subtopic structure from the database
      // Check if subtopic column exists by trying the query and falling back if it fails
      let subtopicsRes;
      let topicSubtopicMap = new Map();
      
      try {
        // Try to get both topic and subtopic
        subtopicsRes = AppState.database.exec("SELECT DISTINCT topic, subtopic FROM questions ORDER BY topic, subtopic");
        
        if (subtopicsRes[0]?.values) {
          subtopicsRes[0].values.forEach(row => {
            const topic = row[0];
            const subtopic = row[1] || 'General';
            
            if (!topicSubtopicMap.has(topic)) {
              topicSubtopicMap.set(topic, new Set());
            }
            topicSubtopicMap.get(topic).add(subtopic);
          });
        }
      } catch (error) {
        console.log("Subtopic column not found, using topic only:", error.message);
        // Fallback: use only topic column and create "General" subtopic for each topic
        try {
          const topicsRes = AppState.database.exec("SELECT DISTINCT topic FROM questions ORDER BY topic");
          if (topicsRes[0]?.values) {
            topicsRes[0].values.forEach(row => {
              const topic = row[0];
              topicSubtopicMap.set(topic, new Set(['General']));
            });
          }
        } catch (fallbackError) {
          console.error("Error getting topics:", fallbackError);
          return;
        }
      }

      // Debug: Log the topic-subtopic mapping
      console.log("Database Topic-Subtopic Map:", topicSubtopicMap);

      const wrapper = document.createElement("div");
      wrapper.className = "filter-panel";

      // Add database name display at the top
      if (AppState.dbFileName) {
        const dbNameDiv = document.createElement("div");
        dbNameDiv.className = "db-name-display";
        dbNameDiv.style.cssText = "margin-bottom: 15px; padding: 10px; background: #e3f2fd; border-left: 4px solid #2196f3; border-radius: 4px; font-weight: bold; color: #1565c0; display: flex; justify-content: space-between; align-items: center;";
        
        // Database name on the left
        const dbNameSpan = document.createElement("span");
        dbNameSpan.innerHTML = `📄 Database: <span style="color: #0d47a1;">${AppState.dbFileName}</span>`;
        
        // Start Test button on the right
        const startTestBtn = document.createElement("button");
        startTestBtn.textContent = "Start Test";
        startTestBtn.style.cssText = "background: #4caf50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold; margin-left: 15px;";
        startTestBtn.id = "topStartTestBtn";
        
        // Store reference to connect later after main button is created
        window.topStartTestButton = startTestBtn;
        
        // Add a direct onclick as backup
        startTestBtn.onclick = () => {
          // We'll connect this to the main button later
        };
        
        // Hover effect for the button
        startTestBtn.onmouseover = () => startTestBtn.style.background = "#45a049";
        startTestBtn.onmouseout = () => startTestBtn.style.background = "#4caf50";
        
        dbNameDiv.appendChild(dbNameSpan);
        dbNameDiv.appendChild(startTestBtn);
        wrapper.appendChild(dbNameDiv);
      }

      // Topics with nested subtopics (DATABASE MODE)
      const topicDiv = document.createElement("div");
      topicDiv.className = "filter-section";
      topicDiv.innerHTML = "<h3>Select Topics & Subtopics (Database)</h3>";
      
      // Select All checkbox
      const selectAllDiv = document.createElement("div");
      selectAllDiv.style.marginBottom = "15px";
      selectAllDiv.style.borderBottom = "1px solid #ddd";
      selectAllDiv.style.paddingBottom = "10px";
      const selectAllLabel = document.createElement("label");
      selectAllLabel.style.fontWeight = "bold";
      selectAllLabel.innerHTML = `<input type="checkbox" id="select-all-topics-db" checked> Select All Topics & Subtopics`;
      selectAllDiv.appendChild(selectAllLabel);
      topicDiv.appendChild(selectAllDiv);

      // Create hierarchical structure
      const topicContainer = document.createElement("div");
      topicContainer.className = "topic-hierarchy";
      
      Array.from(topicSubtopicMap.keys()).sort().forEach(topic => {
        const subtopics = Array.from(topicSubtopicMap.get(topic)).sort();
        
        // Get question count for this topic (all subtopics combined)
        const topicCountRes = AppState.database.exec("SELECT COUNT(*) FROM questions WHERE topic = ?", [topic]);
        const topicQuestionCount = topicCountRes[0]?.values[0][0] || 0;
        
        // Topic level container
        const topicItemDiv = document.createElement("div");
        topicItemDiv.className = "topic-item";
        topicItemDiv.style.marginBottom = "10px";
        
        // Topic checkbox with question count
        const topicLabel = document.createElement("label");
        topicLabel.style.fontWeight = "bold";
        topicLabel.style.display = "block";
        topicLabel.innerHTML = `<input type="checkbox" class="topic-checkbox" value="${topic}" checked> ${topic} <span style="color: #666; font-weight: normal;">(${topicQuestionCount} question${topicQuestionCount === 1 ? '' : 's'})</span>`;
        topicItemDiv.appendChild(topicLabel);
        
        // Subtopics container
        const subtopicsDiv = document.createElement("div");
        subtopicsDiv.className = "subtopics-container";
        subtopicsDiv.style.marginLeft = "20px";
        subtopicsDiv.style.marginTop = "5px";
        
        subtopics.forEach(subtopic => {
          // Get question count for this specific topic/subtopic combination
          const subtopicCountRes = AppState.database.exec("SELECT COUNT(*) FROM questions WHERE topic = ? AND subtopic = ?", [topic, subtopic]);
          const subtopicQuestionCount = subtopicCountRes[0]?.values[0][0] || 0;
          
          const subtopicLabel = document.createElement("label");
          subtopicLabel.style.display = "block";
          subtopicLabel.style.fontSize = "0.9em";
          subtopicLabel.style.marginBottom = "2px";
          subtopicLabel.innerHTML = `<input type="checkbox" class="subtopic-checkbox" data-topic="${topic}" value="${subtopic}" checked> ${subtopic} <span style="color: #666;">(${subtopicQuestionCount} question${subtopicQuestionCount === 1 ? '' : 's'})</span>`;
          subtopicsDiv.appendChild(subtopicLabel);
        });
        
        topicItemDiv.appendChild(subtopicsDiv);
        topicContainer.appendChild(topicItemDiv);
      });
      
      topicDiv.appendChild(topicContainer);
      setupTopicSubtopicCheckboxesDb(topicDiv, updateMaxQuestions);

      // Types
      const typeDiv = document.createElement("div");
      typeDiv.className = "filter-section";
      typeDiv.innerHTML = "<h3>Select Question Types</h3>";
      const allTypes = document.createElement("label");
      allTypes.innerHTML = `<input type=\"checkbox\" value=\"ALL\" checked> ALL <span style="color: #666; font-weight: normal;">(${AppState.dbTotalQuestions} question${AppState.dbTotalQuestions === 1 ? '' : 's'})</span>`;
      typeDiv.appendChild(allTypes);
      types.forEach(t => {
        // Get count for each question type from database
        const typeCountRes = AppState.database.exec(`SELECT COUNT(*) FROM questions WHERE question_type = '${t}'`);
        const typeQuestionCount = typeCountRes[0]?.values[0][0] || 0;
        const l = document.createElement("label");
        l.style.display = "block";
        l.innerHTML = `<input type=\"checkbox\" value=\"${t}\" checked> ${t} <span style="color: #666; font-weight: normal;">(${typeQuestionCount} question${typeQuestionCount === 1 ? '' : 's'})</span>`;
        typeDiv.appendChild(l);
      });
      setupAllCheckbox(typeDiv);

      // Explanation display mode
      const expDiv = document.createElement("div");
      expDiv.className = "filter-section";
      expDiv.innerHTML = "<h3>Explanation & Reference Display</h3>";
      expDiv.innerHTML += `
        <label><input type=\"radio\" name=\"expMode\" value=\"1\" checked> Only when wrong</label><br>
        <label><input type=\"radio\" name=\"expMode\" value=\"2\"> Both when right and wrong</label><br>
        <label><input type=\"radio\" name=\"expMode\" value=\"3\"> Do not display explanations</label>
      `;

      // Test behavior options
      const behaviorDiv = document.createElement("div");
      behaviorDiv.className = "filter-section";
      behaviorDiv.innerHTML = "<h3>Test Behavior Options</h3>";
      behaviorDiv.innerHTML += `
        <label><input type="checkbox" id="tryAgainOptionDb" checked> Allow "Try Again" for incorrect answers</label><br>
        <label><input type="checkbox" id="topicRevealOptionDb" checked> Show Topic/Subtopic when answering</label><br>
        <label><input type="checkbox" id="immediateResultOptionDb" checked> Show result immediately after each answer</label><br>
        <label><input type="checkbox" id="correctAnswerOptionDb" checked> Show correct answer when wrong</label>
        <div style="margin-top: 8px; padding: 8px; background: #f0f8ff; border-radius: 4px; font-size: 0.9em; color: #666;">
          <em>Note: If "immediate result" is OFF, results and selected options will be revealed after the final score</em>
        </div>
      `;

      // Add immediate result option change handler (DB mode)
      setTimeout(() => {
        const immediateResultCheckbox = document.getElementById("immediateResultOptionDb");
        const correctAnswerCheckbox = document.getElementById("correctAnswerOptionDb");
        const tryAgainCheckbox = document.getElementById("tryAgainOptionDb");
        const explanationRadios = expDiv.querySelectorAll('input[name="expMode"]');
        
        immediateResultCheckbox.addEventListener("change", () => {
          if (!immediateResultCheckbox.checked) {
            // When immediate result is turned OFF, disable "Try Again" (incompatible with delayed results)
            tryAgainCheckbox.checked = false;
            tryAgainCheckbox.disabled = true;
            // Keep other options available for user choice - they'll be applied after final score
          } else {
            // When turned back ON, re-enable "Try Again" and set reasonable defaults
            tryAgainCheckbox.disabled = false;
            if (!correctAnswerCheckbox.checked && !tryAgainCheckbox.checked) {
              // If both were unchecked, set reasonable defaults
              correctAnswerCheckbox.checked = true;
              tryAgainCheckbox.checked = true;
            }
            if (explanationRadios[2].checked) {
              // If explanations were set to "none", change to a reasonable default
              explanationRadios[1].checked = true; // "Both when right and wrong"
            }
          }
        });
      }, 0);

      // Number of questions
      const numDiv = document.createElement("div");
      numDiv.className = "filter-section";
      numDiv.innerHTML = `<h3>Number of Questions</h3><input type=\"number\" id=\"numQuestions\" min=\"1\" value=\"10\"> <span id=\"maxQuestionsInfo\" style=\"margin-left:10px; color:#0078d7; font-weight:bold;\"></span>`;

      // Add total question count display at the top
      const totalCountRes = AppState.database.exec('SELECT COUNT(*) FROM questions');
      const totalQuestions = totalCountRes[0]?.values[0][0] || 0;
      AppState.dbTotalQuestions = totalQuestions; // Store for later use
      const totalCountDiv = document.createElement("div");
      totalCountDiv.id = "db-total-question-count";
      totalCountDiv.style = "margin-bottom: 10px; font-size: 1.1em; color: #0078d7; font-weight: bold; text-align: center;";
      totalCountDiv.textContent = `Total questions in database: ${totalQuestions}`;
      wrapper.appendChild(totalCountDiv);

      // Selection mode radio buttons
      const modeDiv = document.createElement("div");
      modeDiv.className = "filter-section";
      modeDiv.style.marginTop = "10px";
      modeDiv.innerHTML = `
        <h3>Selection Mode</h3>
        <label><input type="radio" name="selectionMode" value="random" checked> Random (default)</label><br>
        <label><input type="radio" name="selectionMode" value="balanced"> Balanced (1 per subtopic, then random)</label>
      `;

      // Start button
      const startBtn = document.createElement("button");
      startBtn.textContent = "Start Test";
      
      // Create tooltip container for balanced mode
      const startBtnContainer = document.createElement("div");
      startBtnContainer.className = "tooltip-container";
      startBtnContainer.appendChild(startBtn);
      
      // Tooltip element (initially hidden)
      const tooltip = document.createElement("div");
      tooltip.className = "tooltip";
      tooltip.style.display = "none";
      startBtnContainer.appendChild(tooltip);
      
      // Function to update tooltip content for balanced mode
      function updateBalancedTooltip() {
        const mode = modeDiv.querySelector('input[name="selectionMode"]:checked').value;
        if (mode === 'balanced') {
          tooltip.style.display = "block";
          
          // Get current filter selections for DATABASE MODE (hierarchical structure)
          let selectedTypes = [];
          
          // Get selected question types (this part is the same)
          const typeChecks = typeDiv.querySelectorAll("input[type=checkbox]");
          if (typeChecks[0].checked) {
            selectedTypes = types;
          } else {
            typeChecks.forEach((cb, i) => {
              if (i > 0 && cb.checked) selectedTypes.push(cb.value);
            });
          }
          
          const numInput = document.getElementById("numQuestions");
          const requestedCount = Math.max(1, parseInt(numInput.value) || 10);
          
          // Calculate distribution preview for SOPHISTICATED BALANCED MODE (DATABASE)
          // Check available questions based on subtopic selections
          const selectAllTopics = document.getElementById("select-all-topics-db");
          let availableQuestionCount = 0;
          
          if (selectAllTopics && selectAllTopics.checked) {
            // All topics and subtopics selected
            const countSql = `SELECT COUNT(*) FROM questions WHERE question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
            const countRes = AppState.database.exec(countSql);
            availableQuestionCount = countRes[0]?.values[0][0] || 0;
          } else {
            // Count based on individual subtopic selections
            const selectedSubtopics = topicDiv.querySelectorAll(".subtopic-checkbox:checked");
            
            if (selectedSubtopics.length > 0) {
              const conditions = [];
              selectedSubtopics.forEach(subtopicCb => {
                const topic = subtopicCb.dataset.topic;
                const subtopic = subtopicCb.value;
                conditions.push(`(topic = '${topic}' AND subtopic = '${subtopic}')`);
              });
              
              const countSql = `SELECT COUNT(*) FROM questions WHERE (${conditions.join(' OR ')}) AND question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
              const countRes = AppState.database.exec(countSql);
              availableQuestionCount = countRes[0]?.values[0][0] || 0;
            }
          }
          
          let distributionHTML = "";
          
          if (availableQuestionCount > 0) {
            // Calculate how many topic-subtopic combinations are available
            const selectedSubtopics = topicDiv.querySelectorAll(".subtopic-checkbox:checked");
            const combinationCount = selectAllTopics && selectAllTopics.checked 
              ? Array.from(topicSubtopicMap.keys()).reduce((total, topic) => total + topicSubtopicMap.get(topic).size, 0)
              : selectedSubtopics.length;
            
            // Simple balanced logic: 1 question per subtopic, then fill randomly
            const subtopicsUsed = Math.min(requestedCount, combinationCount);
            const randomQuestions = Math.max(0, requestedCount - combinationCount);
            
            distributionHTML = `
              <h4>Simple Balanced Distribution Preview</h4>
              <div style="margin-bottom: 10px; padding: 8px; background: #e7f3ff; border-radius: 4px; font-size: 0.9em;">
                <div><strong>Available Questions:</strong> ${availableQuestionCount}</div>
                <div><strong>Available Subtopics:</strong> ${combinationCount}</div>
                <div><strong>Strategy:</strong> 1 question per subtopic (${subtopicsUsed} subtopics), then ${randomQuestions} random questions</div>
                ${randomQuestions > 0 ? `<div style="color: #666;"><em>Since you want ${requestedCount} questions but only ${combinationCount} subtopics available, ${randomQuestions} questions will be selected randomly.</em></div>` : ''}
              </div>
              <div class="tooltip-summary">Total: ${Math.min(requestedCount, availableQuestionCount)} questions will be selected</div>
            `;
            
            if (requestedCount > availableQuestionCount) {
              distributionHTML += `
                <div style="margin-top: 8px; padding: 6px; background: #fff3cd; border-radius: 4px; font-size: 0.85em; color: #856404;">
                  ⚠️ Requested ${requestedCount} questions, but only ${availableQuestionCount} available.<br>
                  Will select all ${availableQuestionCount} available questions.
                </div>
              `;
            }
          } else {
            distributionHTML = `
              <h4>Simple Balanced Distribution Preview</h4>
              <div style="text-align: center; color: #856404;">
                No questions available for selected topic/subtopic and question type combinations.<br>
                Please adjust your selections.
              </div>
            `;
          }
          
          tooltip.innerHTML = distributionHTML;
        } else {
          tooltip.style.display = "none";
        }
      }
      
      // Update tooltip when selection mode changes
      modeDiv.addEventListener("change", updateBalancedTooltip);
      
      // Update tooltip when filters change
      topicDiv.addEventListener("change", updateBalancedTooltip);
      typeDiv.addEventListener("change", updateBalancedTooltip);
      
      // Update tooltip when number of questions changes
      setTimeout(() => {
        const numInput = document.getElementById("numQuestions");
        if (numInput) {
          numInput.addEventListener("input", updateBalancedTooltip);
        }
        updateBalancedTooltip(); // Initial update
      }, 0);
      
      startBtn.addEventListener("click", () => {
        // Save current options state before starting test
        saveOptionsState();
        
        document.getElementById("file-chosen").innerHTML = "Loading questions from database and building test...";
        // Get selected topic/subtopic combinations and question types for DATABASE MODE
        let selectedTypes = [];
        
        // Get selected question types (this part is the same)
        const typeChecks = typeDiv.querySelectorAll("input[type=checkbox]");
        if (typeChecks[0].checked) {
          selectedTypes = types;
        } else {
          typeChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTypes.push(cb.value);
          });
        }

        const expChoice = expDiv.querySelector("input[name=expMode]:checked");
        AppState.explanationMode = parseInt(expChoice.value);

        // Capture test behavior options
        AppState.allowTryAgain = document.getElementById("tryAgainOptionDb").checked;
        AppState.showTopicSubtopic = document.getElementById("topicRevealOptionDb").checked;
        AppState.showImmediateResult = document.getElementById("immediateResultOptionDb").checked;
        AppState.showCorrectAnswer = document.getElementById("correctAnswerOptionDb").checked;
        
        // Build SQL query based on subtopic selections
        let sql2;
        const selectAllTopics = document.getElementById("select-all-topics-db");
        
        if (selectAllTopics && selectAllTopics.checked) {
          // All topics and subtopics selected
          sql2 = `SELECT * FROM questions WHERE question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
        } else {
          // Build query based on individual subtopic selections
          const selectedSubtopics = topicDiv.querySelectorAll(".subtopic-checkbox:checked");
          
          if (selectedSubtopics.length === 0) {
            document.getElementById("file-chosen").innerHTML = "No topics or subtopics selected.";
            alert("Please select at least one topic or subtopic.");
            return;
          }
          
          const conditions = [];
          selectedSubtopics.forEach(subtopicCb => {
            const topic = subtopicCb.dataset.topic;
            const subtopic = subtopicCb.value;
            conditions.push(`(topic = '${topic}' AND subtopic = '${subtopic}')`);
          });
          
          sql2 = `SELECT * FROM questions WHERE (${conditions.join(' OR ')}) AND question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
        }

        console.log("Executing SQL query:", sql2);
        const res2 = AppState.database.exec(sql2);
        if (!res2.length) {
          document.getElementById("file-chosen").innerHTML = "No questions found in the database for the selected filters.";
          alert("No questions found in the database for the selected filters.");
          return;
        }
        let allQuestions = res2[0]?.values.map(row => {
          const obj = {};
          res2[0].columns.forEach((col, i) => obj[col] = row[i]);
          return obj;
        }) || [];
        
        // Build valid question objects
        let validQuestions = [];
        allQuestions.forEach((q, index) => {
          let valid = false;
          // MCQ and MCQ-Scenario and Cohort-05-MCQ: fetch options
          if (q.question_type === 'MCQ' || q.question_type === 'MCQ-Scenario' || q.question_type === 'Cohort-05-MCQ') {
            const optRes = AppState.database.exec(`SELECT option_text, is_correct FROM options WHERE question_id = ${q.id}`);
            q.options = optRes[0]?.values?.map(v => v[0]) || [];
            q.answer = optRes[0]?.values?.filter(v => v[1] === 1)?.map(v => v[0]) || [];
            if (q.answer.length === 1) q.answer = q.answer[0];
            valid = q.options.length > 0;
            // For MCQ-Scenario, treat as single or multiple as per answer
            if (q.question_type === 'MCQ-Scenario') {
              q.type = (Array.isArray(q.answer) && q.answer.length > 1) ? 'multiple' : 'single';
            } else if (q.question_type === 'Cohort-05-MCQ') {
              // Cohort-05-MCQ should always be single answer type
              q.type = 'single';
            } else {
              q.type = (Array.isArray(q.answer) && q.answer.length > 1) ? 'multiple' : 'single';
            }
          }
          // TrueFalse: set options and answer
          if (q.question_type === 'TrueFalse') {
            q.options = ["True", "False"];
            // Fetch correct answer from options table
            const optRes = AppState.database.exec(`SELECT option_text, is_correct FROM options WHERE question_id = ${q.id}`);
            const correctOpt = optRes[0]?.values.find(v => v[1] === 1);
            q.answer = correctOpt ? correctOpt[0] : null;
            valid = true;
            q.type = 'single';
          }
          // Match: fetch pairs
          if (q.question_type === 'Match') {
            const matchRes = AppState.database.exec(`SELECT left_text, right_text FROM match_pairs WHERE question_id = ${q.id}`);
            q.matchPairs = {};
            q.matchPairsRaw = matchRes;
            if (matchRes[0] && matchRes[0].values && matchRes[0].values.length > 0) {
              matchRes[0].values.forEach(v => { q.matchPairs[v[0]] = v[1]; });
              valid = Object.keys(q.matchPairs).length > 0;
            } else {
              valid = false;
            }
            q.type = 'match';
          }
          // AssertionReason: fetch assertion/reason/correct_option
          if (q.question_type === 'AssertionReason') {
            const arRes = AppState.database.exec(`SELECT assertion, reason, correct_option FROM assertion_reason WHERE question_id = ${q.id}`);
            if (arRes[0]?.values.length) {
              q.assertion = arRes[0].values[0][0];
              q.reason = arRes[0].values[0][1];
              q.answer = arRes[0].values[0][2];
              // Standard options for assertion-reason
              q.options = [
                "Both A and R are true, and R explains A",
                "Both A and R are true, but R does not explain A",
                "A is true, R is false",
                "A is false, R is true",
                "Both A and R are false"
              ];
              valid = true;
            }
            q.type = 'assertion';
          }
          q.question = q.question_text;
          // Only push if valid
          if (valid) validQuestions.push(q);
        });

        if (validQuestions.length === 0) {
          document.getElementById("file-chosen").innerHTML = "No valid questions found for the selected criteria.";
          alert("No valid questions found. Please check your database structure and selected filters.");
          return;
        }

        // Selection mode logic
        const mode = modeDiv.querySelector('input[name="selectionMode"]:checked').value;
        let chosenQuestions = [];
        const numInput = document.getElementById("numQuestions");
        const numQuestions = Math.max(1, Math.min(parseInt(numInput.value), parseInt(numInput.max)));
        
        if (mode === 'balanced') {
          // SIMPLE BALANCED MODE: One question per subtopic, then fill randomly
          // Much simpler approach: assign 1 question per subtopic up to requested number
          
          // Get available topic-subtopic combinations from the validQuestions
          const availableCombinations = [];
          const combinationMap = new Map();
          
          validQuestions.forEach(q => {
            const combo = `${q.topic}:::${q.subtopic || 'General'}`;
            if (!combinationMap.has(combo)) {
              combinationMap.set(combo, []);
              availableCombinations.push({
                topic: q.topic,
                subtopic: q.subtopic || 'General',
                key: combo
              });
            }
            combinationMap.get(combo).push(q);
          });
          
          console.log(`Available topic-subtopic combinations: ${availableCombinations.length}`);
          console.log("Combinations:", availableCombinations.map(c => `${c.topic}→${c.subtopic} (${combinationMap.get(c.key).length} questions)`));
          
          if (availableCombinations.length === 0) {
            document.getElementById("file-chosen").innerHTML = "No valid topic-subtopic combinations found.";
            return;
          }
          
          // Simple approach: Take 1 question from each subtopic until we have enough
          // If we run out of subtopics, fill the rest randomly
          chosenQuestions = [];
          const usedQuestions = new Set();
          
          // Shuffle combinations to avoid bias in selection order
          const shuffledCombinations = shuffle([...availableCombinations]);
          
          // Take one question from each subtopic up to the requested number
          let questionsNeeded = numQuestions;
          console.log(`Simple balanced approach: Taking 1 question from each subtopic up to ${questionsNeeded} questions`);
          
          for (const combination of shuffledCombinations) {
            if (questionsNeeded <= 0) break;
            
            const availableForCombination = combinationMap.get(combination.key).filter(q => !usedQuestions.has(q.id));
            if (availableForCombination.length > 0) {
              // Pick one random question from this subtopic
              const randomQuestion = availableForCombination[Math.floor(Math.random() * availableForCombination.length)];
              chosenQuestions.push(randomQuestion);
              usedQuestions.add(randomQuestion.id);
              questionsNeeded--;
              console.log(`  Selected 1 question from ${combination.topic}→${combination.subtopic}`);
            }
          }
          
          // If we still need more questions, fill randomly from remaining questions
          if (questionsNeeded > 0) {
            console.log(`Need ${questionsNeeded} more questions. Filling randomly from remaining.`);
            const remainingQuestions = validQuestions.filter(q => !usedQuestions.has(q.id));
            const shuffledRemaining = shuffle(remainingQuestions);
            const additionalQuestions = shuffledRemaining.slice(0, questionsNeeded);
            chosenQuestions = chosenQuestions.concat(additionalQuestions);
            console.log(`Added ${additionalQuestions.length} additional questions randomly`);
          }
          
          console.log(`Final selection: ${chosenQuestions.length} questions`);
          console.log("Distribution by combination:", availableCombinations.map(c => {
            const count = chosenQuestions.filter(q => q.topic === c.topic && (q.subtopic || 'General') === c.subtopic).length;
            return `${c.topic}→${c.subtopic}: ${count}`;
          }));
          
          if (chosenQuestions.length === 0) {
            document.getElementById("file-chosen").innerHTML = "No valid questions found for the selected filters. Please adjust your selection.";
            return;
          }
        } else {
          // Random: shuffle and pick N
          validQuestions = shuffle(validQuestions);
          chosenQuestions = validQuestions.slice(0, numQuestions);
        }
        if (chosenQuestions.length === 0) {
          document.getElementById("file-chosen").innerHTML = "No valid questions found for the selected filters. Please try different options.";
          return;
        }
        document.getElementById("file-chosen").innerHTML = `Loaded ${chosenQuestions.length} questions. Preparing test UI...`;
        
        // Store database query parameters for "New Questions" functionality
        AppState.lastDbQueryParams = {
          selectedTypes: [...selectedTypes],
          mode: mode,
          numQuestions: numQuestions,
          explanationMode: AppState.explanationMode,
          isAllTopicsSelected: selectAllTopics && selectAllTopics.checked,
          selectedSubtopics: null
        };
        
        // Store subtopic selections if not "all topics" mode
        if (!AppState.lastDbQueryParams.isAllTopicsSelected) {
          const selectedSubtopics = topicDiv.querySelectorAll(".subtopic-checkbox:checked");
          AppState.lastDbQueryParams.selectedSubtopics = Array.from(selectedSubtopics).map(cb => ({
            topic: cb.dataset.topic,
            subtopic: cb.value
          }));
        }
        
        setTimeout(() => {
          console.log("=== ABOUT TO CALL startTest() ===");
          console.log("Final chosen questions count:", chosenQuestions.length);
          panel.innerHTML = ""; // Clear filter panel before starting test
          document.getElementById("restart").style.display = "none"; // Hide restart until questions are shown
          document.getElementById("restart-bottom").style.display = "none";
          startTest(chosenQuestions);
        }, 500);
      });

      // Connect the top "Start Test" button to trigger the main button's click event
      const topStartTestBtn = window.topStartTestButton; // Use stored reference instead of getElementById
      if (topStartTestBtn) {
        // Update the onclick handler to trigger the main button
        topStartTestBtn.onclick = () => {
          console.log("Top Start Test button clicked - delegating to main button");
          console.log("Main startBtn exists:", !!startBtn);
          console.log("Main startBtn disabled:", startBtn.disabled);
          startBtn.click(); // Simply trigger the main start button's click
        };
      }

      // Update max questions info and input limit dynamically
      function updateMaxQuestions() {
        console.log("updateMaxQuestions called"); // Debug log
        // Get selected topic/subtopic combinations and question types for DATABASE MODE
        let selectedTypes = [];
        
        // Get selected question types (this part is the same)
        const typeChecks = typeDiv.querySelectorAll("input[type=checkbox]");
        if (typeChecks[0].checked) {
          selectedTypes = types;
        } else {
          typeChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTypes.push(cb.value);
          });
        }
        
        if (selectedTypes.length === 0) {
          document.getElementById("maxQuestionsInfo").textContent = "Max: 0 questions available (no question types selected)";
          const numInput = document.getElementById("numQuestions");
          numInput.max = 0;
          startBtn.disabled = true;
          return;
        }
        
        // Get selected topic/subtopic combinations using hierarchical structure
        const selectAllTopics = document.getElementById("select-all-topics-db");
        let totalQuestions = 0;
        
        if (selectAllTopics && selectAllTopics.checked) {
          // All topics and subtopics selected - count all questions with selected types
          const sql = `SELECT COUNT(*) FROM questions WHERE question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
          const res = AppState.database.exec(sql);
          totalQuestions = res[0]?.values[0][0] || 0;
        } else {
          // Count questions based on individual subtopic selections
          const selectedSubtopics = topicDiv.querySelectorAll(".subtopic-checkbox:checked");
          console.log("Selected subtopics:", selectedSubtopics.length); // Debug log
          
          if (selectedSubtopics.length === 0) {
            totalQuestions = 0;
          } else {
            // Build a query for each selected topic/subtopic combination
            const conditions = [];
            selectedSubtopics.forEach(subtopicCb => {
              const topic = subtopicCb.dataset.topic;
              const subtopic = subtopicCb.value;
              conditions.push(`(topic = '${topic}' AND subtopic = '${subtopic}')`);
            });
            
            const sql = `SELECT COUNT(*) FROM questions WHERE (${conditions.join(' OR ')}) AND question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
            console.log("SQL query:", sql); // Debug log
            const res = AppState.database.exec(sql);
            totalQuestions = res[0]?.values[0][0] || 0;
          }
        }
        
        document.getElementById("maxQuestionsInfo").textContent = `Max: ${totalQuestions} question${totalQuestions === 1 ? '' : 's'} available for selection`;
        const numInput = document.getElementById("numQuestions");
        numInput.max = totalQuestions;
        
        // Only auto-adjust if the current value is invalid, otherwise preserve user input
        const currentValue = parseInt(numInput.value) || 0;
        if (currentValue < 1) {
          numInput.value = Math.min(10, totalQuestions);
        } else if (currentValue > totalQuestions) {
          numInput.value = totalQuestions;
        }
        
        // Disable start button if value < 1 or > max
        startBtn.disabled = (totalQuestions < 1 || parseInt(numInput.value) < 1 || parseInt(numInput.value) > totalQuestions);
      }
      // Attach listeners to topic/type checkboxes and numQuestions input
      topicDiv.addEventListener("change", updateMaxQuestions);
      typeDiv.addEventListener("change", updateMaxQuestions);
      setTimeout(() => {
        const numInput = document.getElementById("numQuestions");
        if (numInput) numInput.addEventListener("input", updateMaxQuestions);
        updateMaxQuestions();
      }, 0);
      
  // Create button container for Start Test button
  const buttonContainer = document.createElement("div");
  buttonContainer.style.marginTop = "20px";
  buttonContainer.style.textAlign = "center";
  
  // Create Reset to Defaults button for DB mode
  const resetBtn = document.createElement("button");
  resetBtn.textContent = "Reset to Defaults";
  resetBtn.className = "custom-btn";
  resetBtn.style.marginRight = "10px";
  resetBtn.style.backgroundColor = "#f5f5f5";
  resetBtn.style.color = "#333";
  resetBtn.style.border = "1px solid #ccc";
  
  resetBtn.addEventListener("click", () => {
    // Reset all selections to defaults
    
    // Reset to "All Topics and Subtopics"
    const selectAllTopics = document.getElementById("select-all-topics-db");
    if (selectAllTopics) {
      selectAllTopics.checked = true;
      selectAllTopics.dispatchEvent(new Event('change')); // Trigger the change event
    }
    
    // Reset types - check "All Types"
    const typeChecks = typeDiv.querySelectorAll("input[type=checkbox]");
    typeChecks.forEach((cb, i) => {
      cb.checked = i === 0; // Only check "All Types"
    });
    
    // Reset explanation mode to "Both when right and wrong" (value 1)
    const expRadios = expDiv.querySelectorAll("input[name=expMode]");
    expRadios.forEach(radio => {
      radio.checked = radio.value === "1";
    });
    
    // Reset behavior options to defaults
    document.getElementById("tryAgainOptionDb").checked = true;
    document.getElementById("topicRevealOptionDb").checked = true;
    document.getElementById("immediateResultOptionDb").checked = true;
    document.getElementById("correctAnswerOptionDb").checked = true;
    
    // Update AppState with default values
    AppState.allowTryAgain = true;
    AppState.showTopicSubtopic = true;
    AppState.showImmediateResult = true;
    AppState.showCorrectAnswer = true;
    AppState.explanationMode = 1; // "Only when wrong"
    
    // Clear persistent saved settings to prevent restoration
    AppState.savedDbOptions = null;
    
    // Update immediate result option state (trigger change event to apply DOM logic)
    document.getElementById("immediateResultOptionDb").dispatchEvent(new Event('change'));
    
    // Reset number of questions to default (10 or max available)
    const numInput = document.getElementById("numQuestionsDb");
    if (numInput) {
      numInput.value = 10;
    }
    
    // Reset selection mode to random
    const selectionModeRadios = modeDiv.querySelectorAll("input[name=selectionMode]");
    selectionModeRadios.forEach(radio => {
      radio.checked = radio.value === "random";
    });
    
    console.log("Reset all DB options to defaults");
  });
  
  buttonContainer.appendChild(resetBtn);
  buttonContainer.appendChild(startBtnContainer);
  
  wrapper.appendChild(topicDiv);
  wrapper.appendChild(typeDiv);
  wrapper.appendChild(expDiv);
  wrapper.appendChild(behaviorDiv);
  wrapper.appendChild(numDiv);
  wrapper.appendChild(modeDiv);
  wrapper.appendChild(buttonContainer);
  panel.appendChild(wrapper);
  
  // Restore previously saved options state after all event listeners are set up
  if (!skipRestore) {
    setTimeout(() => {
      restoreOptionsState();
    }, 100);
  }
    }

    // Utility: Show total question count in DB in file-chosen area for debugging
    function showTotalDbQuestions() {
      if (!db) return;
      const res = AppState.database.exec('SELECT COUNT(*) FROM questions');
      const total = res[0]?.values[0][0] || 0;
      document.getElementById('file-chosen').innerHTML = `<span style='color:#0078d7; font-weight:bold;'>Total questions in DB: ${total}</span>`;
    }
    // Call this after DB loads
    if (typeof showTotalDbQuestions === 'function') setTimeout(showTotalDbQuestions, 500);

    function startTest(filteredQuestions) {
      try {
        document.getElementById("file-chosen").innerHTML = "";
        const container = document.getElementById("test");
        container.innerHTML = "";
        
        // Hide the how-to-use guide when test starts
        const guideElement = document.getElementById("how-to-use-guide");
        if (guideElement) {
          guideElement.style.display = "none";
        }
        
        // Hide file selection buttons during test (Choose JSON and Choose DB)
        const chooseJsonLabel = document.querySelector('label[for="fileInput"]');
        const chooseDbButton = document.getElementById("chooseDb");
        if (chooseJsonLabel) {
          chooseJsonLabel.style.display = "none";
        }
        if (chooseDbButton) {
          chooseDbButton.style.display = "none";
        }
        
        document.getElementById("restart").style.display = "inline-block";
        document.getElementById("backToOptions").style.display = "inline-block";
        document.getElementById("newTestSameOptions").style.display = "inline-block";
        document.getElementById("newtest").style.display = "none";
        document.getElementById("scoreboard").innerHTML = "";
        AppState.score = 0;
        AppState.questionResults = []; // Reset question results for new test
        document.getElementById("test-title").innerHTML = "InsightPrep<br><span style='font-size: 0.75em; font-weight: normal; color: #e6f3ff; margin-top: 5px; display: inline-block;'>Where Preparation Meets Reflection</span>";
        // Scroll to top when test begins
        window.scrollTo({ top: 0, behavior: "smooth" });
        // Absolute random shuffle for questions
        const shuffledQuestions = shuffle(filteredQuestions.map(q => ({ ...q })));
        // Absolute random shuffle for options in every question
        AppState.questions = shuffledQuestions.map(q => {
          if (q.options) q.options = shuffle([...q.options]);
          return q;
        });
        // Save last used filters for restart
        AppState.lastFilteredQuestions = AppState.questions.map(q => ({ ...q }));
        AppState.lastExplanationMode = AppState.explanationMode;
        renderTest(AppState.questions);
      } catch (err) {
        document.getElementById("file-chosen").innerHTML = `<pre style='color:red;'>Error rendering test: ${err.message}</pre>`;
        document.getElementById("test").innerHTML = "";
      }
    }

    function renderTest(questions) {
      try {
        if (!Array.isArray(questions) || questions.length === 0) {
          document.getElementById("file-chosen").innerHTML = `<pre style='color:red;'>Error: No questions to display. Please check your filters or database content.</pre>`;
          document.getElementById("test").innerHTML = "";
          return;
        }
        const container = document.getElementById("test");
        container.innerHTML = "";

        questions.forEach((q, qIndex) => {
          const qDiv = document.createElement("div");
          qDiv.className = "question-card";
          qDiv.id = `q-${q.id}`;
          qDiv.style.position = 'relative';

          const qTitle = document.createElement("h3");
          qTitle.textContent = `${qIndex + 1}. ${q.question}`;
          qDiv.appendChild(qTitle);

          if ((q.type === "single" || q.type === "assertion" || q.type === "MCQ-Scenario") && Array.isArray(q.options)) {
            q.options.forEach(opt => {
              const label = document.createElement("label");
              label.style.display = "block";
              const input = document.createElement("input");
              input.type = "radio";
              input.name = `q${q.id}`;
              input.value = opt;
              input.addEventListener("change", () => {
                handleAnswer(q, [opt], qDiv, qIndex);
              });
              label.appendChild(input);
              label.append(" " + opt);
              qDiv.appendChild(label);
            });
          } else if (q.type === "multiple" && Array.isArray(q.options)) {
            q.options.forEach(opt => {
              const label = document.createElement("label");
              label.style.display = "block";
              const input = document.createElement("input");
              input.type = "checkbox";
              input.name = `q${q.id}`;
              input.value = opt;
              label.appendChild(input);
              label.append(" " + opt);
              qDiv.appendChild(label);
            });

            const submitBtn = document.createElement("button");
            submitBtn.textContent = "Submit Answer";
            submitBtn.title = "Submit your selected answers for this question. You can select multiple options.";
            submitBtn.addEventListener("click", () => {
              const selected = Array.from(qDiv.querySelectorAll(`input[name="q${q.id}"]:checked`)).map(inp => inp.value);
              handleAnswer(q, selected, qDiv, qIndex);
            });
            qDiv.appendChild(submitBtn);
          } else if (q.type === "match" && q.matchPairs && typeof q.matchPairs === 'object' && Object.keys(q.matchPairs).length > 0) {
            createMatchQuestion(q, qDiv, qIndex);
          } else {
            qDiv.innerHTML += `<div style='color:red;'>Error: Question data is incomplete or malformed.</div>`;
          }

          container.appendChild(qDiv);
        });

        // After all question cards are created, set disabled/active classes
        questions.slice(1).forEach(q => {
          const el = document.getElementById(`q-${q.id}`);
          if (el) el.classList.add("disabled");
        });
        const firstEl = document.getElementById(`q-${questions[0]?.id}`);
        if (firstEl) firstEl.classList.add("active");
      } catch (err) {
        document.getElementById("file-chosen").innerHTML = `<pre style='color:red;'>Error rendering questions: ${err.message}</pre>`;
        document.getElementById("test").innerHTML = "";
      }
    }

    function handleAnswer(question, chosen, qDiv, qIndex) {
      if (qDiv.classList.contains("locked")) return;

      qDiv.classList.remove("active");
      qDiv.classList.add("locked");

      let isCorrect = false;

      if (question.type === "single" || question.type === "assertion") {
        isCorrect = (chosen[0] === question.answer);
      }
      else if (question.type === "multiple") {
        const correct = new Set(question.answer);
        const selected = new Set(chosen);
        isCorrect = (correct.size === selected.size && [...correct].every(x => selected.has(x)));
      }
      else if (question.type === "match") {
        isCorrect = JSON.stringify(chosen) === JSON.stringify(question.matchPairs);
      }

  // Remove any previous try-again container
  const prevTryContainer = qDiv.querySelector('.try-again-container');
  if (prevTryContainer) prevTryContainer.remove();

      // Remove all visible try again buttons for all questions
      document.querySelectorAll('[id^="try-again-outer-container-"]').forEach(el => {
        if (el && el.parentNode) el.parentNode.removeChild(el);
      });
      
      if (isCorrect) {
        // Store the result for this question
        AppState.questionResults[qIndex] = { isCorrect: true, userAnswer: chosen };
        
        if (AppState.showImmediateResult) {
          qDiv.insertAdjacentHTML("beforeend", `<p class="correct">✅ Correct!</p>`);
        }
        AppState.score++;
        console.log(`Question ${qIndex + 1} answered correctly. Score: ${AppState.score}/${AppState.questions.length}`);
        // Unlock next question or show score
        const nextQ = document.getElementById(`q-${AppState.questions[qIndex + 1]?.id}`);
        console.log(`Looking for next question at index ${qIndex + 1}:`, nextQ ? "Found" : "Not found (this was the last question)");
        if (nextQ) {
          // Only enable the next question, keep all others after it disabled
          nextQ.classList.remove("disabled");
          nextQ.classList.remove("locked");
          nextQ.classList.add("active");
          
          // Ensure all questions after the next one remain disabled
          for (let i = qIndex + 2; i < AppState.questions.length; i++) {
            const laterQ = document.getElementById(`q-${AppState.questions[i].id}`);
            if (laterQ) {
              laterQ.classList.add('disabled');
              laterQ.classList.remove('active');
              laterQ.classList.remove('locked');
            }
          }
        } else {
          console.log("This was the last question! Calling showFinalScore()");
          showFinalScore();
        }
        // Always highlight next question after any answer
        setTimeout(() => {
          document.querySelectorAll('.question-card').forEach(card => {
            card.style.boxShadow = '';
            card.classList.remove('active');
          });
          if (nextQ) {
            nextQ.classList.add('active');
          }
        }, 10);
      } else {
        // Store the result for this question
        AppState.questionResults[qIndex] = { isCorrect: false, userAnswer: chosen };
        
        // Show wrong message - only if immediate result is enabled
        if (AppState.showImmediateResult) {
          qDiv.insertAdjacentHTML("beforeend", `<p class=\"wrong\">❌ <b>Wrong.</b></p>`);
        }
        
        // Enable the next question after wrong answer too, but keep all others disabled
        const nextQ = document.getElementById(`q-${AppState.questions[qIndex + 1]?.id}`);
        console.log(`Wrong answer on question ${qIndex + 1}. Looking for next question:`, nextQ ? "Found" : "Not found (this was the last question)");
        if (nextQ) {
          nextQ.classList.remove("disabled");
          nextQ.classList.remove("locked");
          nextQ.classList.remove("active"); // Don't make it active yet, user can choose to continue or retry
          
          // Ensure all questions after the next one remain disabled
          for (let i = qIndex + 2; i < AppState.questions.length; i++) {
            const laterQ = document.getElementById(`q-${AppState.questions[i].id}`);
            if (laterQ) {
              laterQ.classList.add('disabled');
              laterQ.classList.remove('active');
              laterQ.classList.remove('locked');
            }
          }
        } else {
          // This was the last question, even though answered wrong, show final score
          console.log("Last question answered incorrectly. Showing final score.");
          showFinalScore();
        }
        
        // Place Try Again button just below and close to the card, only if answered wrong AND if Try Again is enabled
        if (AppState.allowTryAgain) {
          // Remove any previous try again container for this card
          const prevTryAgain = document.getElementById('try-again-outer-container-' + qIndex);
          if (prevTryAgain && prevTryAgain.parentNode) {
            prevTryAgain.parentNode.removeChild(prevTryAgain);
          }
          const newOuter = document.createElement('div');
          newOuter.id = 'try-again-outer-container-' + qIndex;
          newOuter.style.display = 'flex';
          newOuter.style.justifyContent = 'flex-end';
          newOuter.style.marginTop = '-16px'; // bring closer to card
          newOuter.style.marginBottom = '24px';
          newOuter.style.width = qDiv.offsetWidth ? qDiv.offsetWidth + 'px' : '100%';
          const tryBtn = document.createElement('button');
          tryBtn.textContent = 'Try again';
          tryBtn.className = 'try-again-btn';
    tryBtn.style.background = '#ff9800';
    tryBtn.style.color = 'black';
          tryBtn.style.border = 'none';
          tryBtn.style.borderRadius = '4px';
          tryBtn.style.padding = '4px 12px';
          tryBtn.style.fontWeight = 'bold';
          tryBtn.style.cursor = 'pointer';
          tryBtn.title = 'Try this question again with shuffled options.';
          tryBtn.onclick = function() {
            // Remove the try again button container immediately
            const tryAgainContainer = document.getElementById('try-again-outer-container-' + qIndex);
            if (tryAgainContainer && tryAgainContainer.parentNode) {
              tryAgainContainer.parentNode.removeChild(tryAgainContainer);
            }
            Array.from(qDiv.children).forEach((el, idx) => { if (idx > 0) qDiv.removeChild(el); });
            qDiv.classList.remove('locked');
            let qCopy = { ...question };
            if (qCopy.options) qCopy.options = shuffle([...qCopy.options]);
            if (qCopy.type === 'match' && qCopy.matchPairs) {
              qCopy = { ...qCopy, matchPairs: { ...qCopy.matchPairs } };
            }
            renderSingleQuestion(qCopy, qDiv, qIndex);
            // Highlight the retried card only after pressing Try again
            setTimeout(() => {
              document.querySelectorAll('.question-card').forEach(card => {
                card.style.boxShadow = '';
                card.classList.remove('active');
              });
              qDiv.classList.add('active');
            }, 10);
          };
          newOuter.appendChild(tryBtn);
          // Insert after the card
          if (qDiv.parentNode) {
            if (qDiv.nextSibling) {
              qDiv.parentNode.insertBefore(newOuter, qDiv.nextSibling);
            } else {
              qDiv.parentNode.appendChild(newOuter);
            }
          }
        }
        // Always highlight and activate next question after any answer (even if wrong)
        setTimeout(() => {
          document.querySelectorAll('.question-card').forEach(card => {
            card.style.boxShadow = '';
            card.classList.remove('active');
          });
          if (nextQ) {
            nextQ.classList.add('active'); // Make next question active after wrong answer too
          }
        }, 10);
        // Show correct answer and explanation for wrong answers (based on explanation mode) - only if immediate results are enabled
        if (AppState.showImmediateResult && (AppState.explanationMode === 2 || (AppState.explanationMode === 1 && !isCorrect))) {
          // Display the correct answer - only if enabled
          if (AppState.showCorrectAnswer) {
            if (question.type === "single" || question.type === "assertion") {
              qDiv.insertAdjacentHTML("beforeend", `<p class="correct-answer">✓ Correct answer: ${question.answer}</p>`);
            } else if (question.type === "multiple") {
              const correctAnswers = Array.isArray(question.answer) ? question.answer : [question.answer];
              qDiv.insertAdjacentHTML("beforeend", `<p class="correct-answer">✓ Correct answers: ${correctAnswers.join(', ')}</p>`);
            } else if (question.type === "match") {
              // Convert matchPairs object to array of pairs for display
              const matchDisplay = Object.entries(question.matchPairs).map(([left, right]) => `${left} → ${right}`).join(', ');
              qDiv.insertAdjacentHTML("beforeend", `<p class="correct-answer">✓ Correct matches: ${matchDisplay}</p>`);
            }
          }
          
          if (question.explanation) {
            qDiv.insertAdjacentHTML("beforeend", `<p class="explanation">💡 Explanation: ${question.explanation}</p>`);
          }
          if (question.reference) {
            qDiv.insertAdjacentHTML("beforeend", `<p class="reference">📖 Reference: ${question.reference}</p>`);
          }
        }
      }
      
      // Add topic and subtopic information after answer (for both correct and incorrect) - only if enabled and immediate results are on
      if (AppState.showImmediateResult && AppState.showTopicSubtopic) {
        const topicSubtopicInfo = document.createElement("div");
        topicSubtopicInfo.className = "topic-subtopic-info";
        topicSubtopicInfo.style.cssText = "margin-top: 10px; padding: 8px; background: #f8f9fa; border-left: 1px solid #0078d7; font-size: 0.9em; color: #666;";
        
        let topicText = question.topic || "Unknown Topic";
        let subtopicText = question.subtopic || "General";
        
        topicSubtopicInfo.innerHTML = `<strong>Topic:</strong> ${topicText} | <strong>Subtopic:</strong> ${subtopicText}`;
        qDiv.appendChild(topicSubtopicInfo);
      }
    }

    // Helper to re-render a single question in place (for Try Again)
    function renderSingleQuestion(q, qDiv, qIndex) {
    // Remove all children except the title
    Array.from(qDiv.children).forEach((el, idx) => { if (idx > 0) qDiv.removeChild(el); });
    // Always reset state for retry
    qDiv.classList.remove('locked');
    qDiv.classList.remove('active');
    // Remove any previous try again button for this card (ensure it disappears on retry)
    const prevTryAgain = document.getElementById('try-again-outer-container-' + qIndex);
    if (prevTryAgain && prevTryAgain.parentNode) {
      prevTryAgain.parentNode.removeChild(prevTryAgain);
    }
    
    // Disable all questions below this one and remove any try-again buttons
    for (let i = qIndex + 1; i < AppState.questions.length; i++) {
      const nextQDiv = document.getElementById(`q-${AppState.questions[i].id}`);
      if (nextQDiv) {
        nextQDiv.classList.add('disabled');
        nextQDiv.classList.remove('locked');
        nextQDiv.classList.remove('active');
        
        // Remove any existing try-again buttons for questions below
        const nextTryAgain = document.getElementById('try-again-outer-container-' + i);
        if (nextTryAgain && nextTryAgain.parentNode) {
          nextTryAgain.parentNode.removeChild(nextTryAgain);
        }
        
        // Remove correct/wrong status messages from questions below
        const correctMsg = nextQDiv.querySelector('.correct');
        const wrongMsg = nextQDiv.querySelector('.wrong');
        if (correctMsg) correctMsg.remove();
        if (wrongMsg) wrongMsg.remove();
        
        // Remove explanation and reference from questions below
        const explanation = nextQDiv.querySelector('.explanation');
        const reference = nextQDiv.querySelector('.reference');
        if (explanation) explanation.remove();
        if (reference) reference.remove();
        
        // Remove topic/subtopic info from questions below
        const topicSubtopicInfo = nextQDiv.querySelector('.topic-subtopic-info');
        if (topicSubtopicInfo) topicSubtopicInfo.remove();
      }
    }
    
    // Ensure relative positioning for try again button
    qDiv.style.position = 'relative';
      if ((q.type === "single" || q.type === "assertion") && Array.isArray(q.options)) {
        q.options.forEach(opt => {
          const label = document.createElement("label");
          label.style.display = "block";
          const input = document.createElement("input");
          input.type = "radio";
          input.name = `q${q.id}_retry`;
          input.value = opt;
          input.addEventListener("change", () => {
            handleAnswer(q, [opt], qDiv, qIndex);
          });
          label.appendChild(input);
          label.append(" " + opt);
          qDiv.appendChild(label);
        });
      }
      else if (q.type === "multiple" && Array.isArray(q.options)) {
        q.options.forEach(opt => {
          const label = document.createElement("label");
          label.style.display = "block";
          const input = document.createElement("input");
          input.type = "checkbox";
          input.name = `q${q.id}_retry`;
          input.value = opt;
          label.appendChild(input);
          label.append(" " + opt);
          qDiv.appendChild(label);
        });
        const submitBtn = document.createElement("button");
        submitBtn.textContent = "Submit Answer";
        submitBtn.title = "Submit your selected answers for this question. You can select multiple options.";
        submitBtn.addEventListener("click", () => {
          const selected = Array.from(qDiv.querySelectorAll("input[type=checkbox][name='q" + q.id + "_retry']:checked"))
            .map(cb => cb.value);
          handleAnswer(q, selected, qDiv, qIndex);
        });
        qDiv.appendChild(submitBtn);
      }
      else if (q.type === "match" && q.matchPairs && typeof q.matchPairs === 'object' && Object.keys(q.matchPairs).length > 0) {
        createMatchQuestion(q, qDiv, qIndex);
      }

      // Highlight this card if not locked (for retry)
      setTimeout(() => {
        document.querySelectorAll('.question-card').forEach(card => {
          card.style.boxShadow = '';
          card.classList.remove('active');
        });
        if (!qDiv.classList.contains('locked')) {
          qDiv.classList.add('active');
        }
      }, 10);
  }

    function showFinalScore() {
      console.log("showFinalScore() called!");
      const total = AppState.questions.length;
      const percent = Math.round((AppState.score / total) * 100);
      console.log(`Final score: ${AppState.score}/${total} (${percent}%)`);

      let message = "";
      let cssClass = "";

      if (percent >= 90) {
        message = "🌟 Outstanding performance! You’ve clearly mastered the material.";
        cssClass = "excellent";
      } else if (percent >= 70) {
        message = "👍 Well done! You have a strong grasp, revise the missed parts.";
        cssClass = "good";
      } else if (percent >= 50) {
        message = "😊 Decent effort! Review the gaps and practice more.";
        cssClass = "fair";
      } else {
        message = "🙌 Keep trying! Revise basics and practice step by step.";
        cssClass = "poor";
      }

      document.getElementById("scoreboard").innerHTML = `
        <div style="text-align: center; margin-bottom: 20px;">
          <h2 style="color: #0078d7; margin: 0; font-size: 1.8em;">InsightPrep</h2>
          <p style="color: #666; margin: 5px 0 0 0; font-style: italic;">Where Preparation Meets Reflection</p>
        </div>
        <div><strong>Your Score:</strong> ${AppState.score} / ${total} (${percent}%)</div>
        <div id="message" class="${cssClass}">${message}</div>
      `;

      // If immediate results were OFF, now reveal the correct/incorrect status for each question
      if (!AppState.showImmediateResult) {
        AppState.questions.forEach((question, qIndex) => {
          const qDiv = document.getElementById(`q-${question.id}`);
          if (qDiv && AppState.questionResults[qIndex]) {
            const result = AppState.questionResults[qIndex];
            
            // Remove any existing result indicators
            const existingResults = qDiv.querySelectorAll('.correct, .wrong, .correct-answer');
            existingResults.forEach(el => el.remove());
            
            // Add the result indicator
            if (result.isCorrect) {
              qDiv.insertAdjacentHTML("beforeend", `<p class="correct">✅ Correct!</p>`);
            } else {
              qDiv.insertAdjacentHTML("beforeend", `<p class="wrong">❌ <b>Wrong.</b></p>`);
            }
            
            // Show correct answers based on explanation mode and showCorrectAnswer setting
            if (AppState.showCorrectAnswer && (AppState.explanationMode === 2 || (AppState.explanationMode === 1 && !result.isCorrect))) {
              if (question.type === "match") {
                // Convert matchPairs object to array of pairs for display
                const matchDisplay = Object.entries(question.matchPairs).map(([left, right]) => `${left} → ${right}`).join(', ');
                qDiv.insertAdjacentHTML("beforeend", `<p class="correct-answer">✓ Correct matches: ${matchDisplay}</p>`);
              } else if (question.type === "single" || question.type === "assertion") {
                qDiv.insertAdjacentHTML("beforeend", `<p class="correct-answer">✓ Correct answer: ${question.answer}</p>`);
              } else if (question.type === "multiple") {
                const correctAnswers = Array.isArray(question.answer) ? question.answer : [question.answer];
                qDiv.insertAdjacentHTML("beforeend", `<p class="correct-answer">✓ Correct answers: ${correctAnswers.join(', ')}</p>`);
              }
            }
            
            // Show explanations and references based on explanation mode
            if (AppState.explanationMode === 2 || (AppState.explanationMode === 1 && !result.isCorrect)) {
              if (question.explanation) {
                qDiv.insertAdjacentHTML("beforeend", `<p class="explanation">💡 Explanation: ${question.explanation}</p>`);
              }
              if (question.reference) {
                qDiv.insertAdjacentHTML("beforeend", `<p class="reference">📖 Reference: ${question.reference}</p>`);
              }
            }
            
            // Add topic and subtopic information if enabled
            if (AppState.showTopicSubtopic) {
              // Remove any existing topic/subtopic info first
              const existingTopicInfo = qDiv.querySelector('.topic-subtopic-info');
              if (existingTopicInfo) existingTopicInfo.remove();
              
              const topicSubtopicInfo = document.createElement("div");
              topicSubtopicInfo.className = "topic-subtopic-info";
              topicSubtopicInfo.style.cssText = "margin-top: 10px; padding: 8px; background: #f8f9fa; border-left: 1px solid #0078d7; font-size: 0.9em; color: #666;";
              
              let topicText = question.topic || "Unknown Topic";
              let subtopicText = question.subtopic || "General";
              
              topicSubtopicInfo.innerHTML = `<strong>Topic:</strong> ${topicText} | <strong>Subtopic:</strong> ${subtopicText}`;
              qDiv.appendChild(topicSubtopicInfo);
            }
          }
        });
      }

      document.getElementById("restart").style.display = "inline-block";
      document.getElementById("restart-bottom").style.display = "inline-block";
      document.getElementById("backToOptions").style.display = "inline-block";
      document.getElementById("backToOptions-bottom").style.display = "inline-block";
      document.getElementById("newTestSameOptions").style.display = "inline-block";
      document.getElementById("newTestSameOptions-bottom").style.display = "inline-block";
      document.getElementById("newtest").style.display = "inline-block";
    }

    // Helper function to run database query and start test with current selections
    function rerunDatabaseTest() {
      if (!AppState.isDbMode) {
        // Not in database mode, just restart with last filtered questions
        if (AppState.lastFilteredQuestions && AppState.lastFilteredQuestions.length > 0) {
          AppState.explanationMode = AppState.lastExplanationMode;
          startTest(AppState.lastFilteredQuestions);
        }
        return;
      }

      // Check if we have stored query parameters
      if (!AppState.lastDbQueryParams) {
        alert("No previous query parameters found. Please use 'Back to Options' to select filters again.");
        return;
      }

      try {
        document.getElementById("file-chosen").innerHTML = "Loading new set of questions from database...";
        
        const params = AppState.lastDbQueryParams;
        AppState.explanationMode = params.explanationMode;
        
        // Build SQL query based on stored selections
        let sql2;
        
        if (params.isAllTopicsSelected) {
          // All topics and subtopics selected
          sql2 = `SELECT * FROM questions WHERE question_type IN (${params.selectedTypes.map(t => `'${t}'`).join(',')})`;
        } else {
          // Build query based on stored subtopic selections
          if (!params.selectedSubtopics || params.selectedSubtopics.length === 0) {
            alert("No stored subtopic selections found. Please use 'Back to Options' to select filters again.");
            return;
          }
          
          const conditions = [];
          params.selectedSubtopics.forEach(selection => {
            conditions.push(`(topic = '${selection.topic}' AND subtopic = '${selection.subtopic}')`);
          });
          
          sql2 = `SELECT * FROM questions WHERE (${conditions.join(' OR ')}) AND question_type IN (${params.selectedTypes.map(t => `'${t}'`).join(',')})`;
        }

        // Execute database query
        const res2 = AppState.database.exec(sql2);
        if (!res2.length) {
          document.getElementById("file-chosen").innerHTML = "No questions found in the database for the stored filters.";
          alert("No questions found in the database for the stored filters.");
          return;
        }

        // Process questions (same logic as original)
        let allQuestions = res2[0]?.values.map(row => {
          const obj = {};
          res2[0].columns.forEach((col, i) => obj[col] = row[i]);
          return obj;
        }) || [];

        // Build valid question objects (reuse the same logic)
        let validQuestions = [];
        allQuestions.forEach(q => {
          let valid = false;
          // MCQ and MCQ-Scenario and Cohort-05-MCQ: fetch options
          if (q.question_type === 'MCQ' || q.question_type === 'MCQ-Scenario' || q.question_type === 'Cohort-05-MCQ') {
            const optRes = AppState.database.exec(`SELECT option_text, is_correct FROM options WHERE question_id = ${q.id}`);
            q.options = optRes[0]?.values?.map(v => v[0]) || [];
            q.answer = optRes[0]?.values?.filter(v => v[1] === 1)?.map(v => v[0]) || [];
            if (q.answer.length === 1) q.answer = q.answer[0];
            valid = q.options.length > 0;
            // Properly handle different MCQ types
            if (q.question_type === 'Cohort-05-MCQ') {
              q.type = 'single'; // Always single answer for Cohort-05-MCQ
            } else {
              q.type = (Array.isArray(q.answer) && q.answer.length > 1) ? 'multiple' : 'single';
            }
          }
          // TrueFalse: set options and answer
          if (q.question_type === 'TrueFalse') {
            q.options = ["True", "False"];
            const optRes = AppState.database.exec(`SELECT option_text, is_correct FROM options WHERE question_id = ${q.id}`);
            const correctOpt = optRes[0]?.values.find(v => v[1] === 1);
            q.answer = correctOpt ? correctOpt[0] : null;
            valid = true;
            q.type = 'single';
          }
          // Match: fetch pairs
          if (q.question_type === 'Match') {
            const matchRes = AppState.database.exec(`SELECT left_text, right_text FROM match_pairs WHERE question_id = ${q.id}`);
            q.matchPairs = {};
            if (matchRes[0] && matchRes[0].values && matchRes[0].values.length > 0) {
              matchRes[0].values.forEach(v => { q.matchPairs[v[0]] = v[1]; });
              valid = Object.keys(q.matchPairs).length > 0;
            }
            q.type = 'match';
          }
          // AssertionReason: fetch assertion/reason/correct_option
          if (q.question_type === 'AssertionReason') {
            const arRes = AppState.database.exec(`SELECT assertion, reason, correct_option FROM assertion_reason WHERE question_id = ${q.id}`);
            if (arRes[0]?.values.length) {
              q.assertion = arRes[0].values[0][0];
              q.reason = arRes[0].values[0][1];
              q.answer = arRes[0].values[0][2];
              q.options = [
                "Both A and R are true, and R explains A",
                "Both A and R are true, but R does not explain A",
                "A is true, R is false",
                "A is false, R is true",
                "Both A and R are false"
              ];
              valid = true;
            }
            q.type = 'assertion';
          }
          q.question = q.question_text;
          if (valid) validQuestions.push(q);
        });

        // Apply selection mode and choose questions
        let chosenQuestions = [];
        if (params.mode === 'balanced') {
          // Use balanced selection logic (simplified version)
          validQuestions = shuffle(validQuestions);
          chosenQuestions = validQuestions.slice(0, params.numQuestions);
        } else {
          // Random selection
          validQuestions = shuffle(validQuestions);
          chosenQuestions = validQuestions.slice(0, params.numQuestions);
        }

        if (chosenQuestions.length === 0) {
          document.getElementById("file-chosen").innerHTML = "No valid questions found for the stored filters.";
          return;
        }

        document.getElementById("file-chosen").innerHTML = `Loaded ${chosenQuestions.length} new questions. Starting test...`;
        setTimeout(() => {
          startTest(chosenQuestions);
        }, 500);

      } catch (err) {
        alert("Error generating new questions: " + err.message);
        console.error("Error in rerunDatabaseTest:", err);
      }
    }

    document.getElementById("restart").addEventListener("click", () => {
      // Use last filters and explanation mode for restart
      if (AppState.lastFilteredQuestions && AppState.lastFilteredQuestions.length > 0) {
        AppState.explanationMode = AppState.lastExplanationMode;
        startTest(AppState.lastFilteredQuestions);
      } else {
        startTest(AppState.originalData.questions);
      }
    });

    document.getElementById("restart-bottom").addEventListener("click", () => {
      // Use last filters and explanation mode for restart
      if (AppState.lastFilteredQuestions && AppState.lastFilteredQuestions.length > 0) {
        AppState.explanationMode = AppState.lastExplanationMode;
        startTest(AppState.lastFilteredQuestions);
      } else {
        startTest(AppState.originalData.questions);
      }
    });

    // Back to Options button functionality
    document.getElementById("backToOptions").addEventListener("click", () => {
      // Clear test area and scoreboard but keep filter panel
      document.getElementById("test").innerHTML = "";
      document.getElementById("scoreboard").innerHTML = "";
      
      // Hide test-specific buttons
      document.getElementById("restart").style.display = "none";
      document.getElementById("restart-bottom").style.display = "none";
      document.getElementById("backToOptions").style.display = "none";
      document.getElementById("backToOptions-bottom").style.display = "none";
      document.getElementById("newTestSameOptions").style.display = "none";
      document.getElementById("newTestSameOptions-bottom").style.display = "none";
      document.getElementById("newtest").style.display = "none";
      
      // Reset the title
      document.getElementById("test-title").innerHTML = "InsightPrep<br><span style=\"font-size: 0.75em; font-weight: normal; color: #e6f3ff; margin-top: 5px; display: inline-block;\">Where Preparation Meets Reflection</span>";
      
      // Show appropriate message based on mode
      if (AppState.isDbMode) {
        // For database mode, show the ready message with total questions
        const totalQuestions = AppState.dbTotalQuestions || "Unknown";
        document.getElementById("file-chosen").innerHTML = `Database ready. Total questions: <strong>${totalQuestions}</strong>. Please select filters and number of questions.`;
        
        // Rebuild the filter panel if we have the data
        if (AppState.dbTopics && AppState.dbTypes) {
          buildDbFilterPanel(AppState.dbTopics, AppState.dbTypes, true); // Skip restore in function
          // Restore settings immediately when going back to options (no delay to prevent flicker)
          restoreOptionsState();
        } else {
          // Fallback: fetch topics and types again
          try {
            const topicsRes = AppState.database.exec("SELECT DISTINCT topic FROM questions");
            const typesRes = AppState.database.exec("SELECT DISTINCT question_type FROM questions");
            const topics = topicsRes[0]?.values.map(v => v[0]) || [];
            const types = typesRes[0]?.values.map(v => v[0]) || [];
            AppState.dbTopics = topics;
            AppState.dbTypes = types;
            buildDbFilterPanel(topics, types, true); // Skip restore in function
            // Restore settings immediately when going back to options (no delay to prevent flicker)
            restoreOptionsState();
          } catch (err) {
            document.getElementById("file-chosen").innerHTML = "Error rebuilding filter panel: " + err.message;
          }
        }
      } else {
        // For JSON mode, show file loaded message
        const totalQuestions = AppState.originalData?.questions?.length || "Unknown";
        document.getElementById("file-chosen").innerHTML = `File loaded. Total questions: <strong>${totalQuestions}</strong>. Please select filters and number of questions.`;
        
        // Rebuild the filter panel for JSON mode
        if (AppState.originalData && AppState.originalData.questions) {
          buildFilterPanel(AppState.originalData.questions, true); // Skip restore in function
          // Restore settings immediately when going back to options (no delay to prevent flicker)
          restoreOptionsState();
        }
      }
      
      // Scroll to top to show the filter panel
      window.scrollTo({ top: 0, behavior: "smooth" });
    });

    document.getElementById("backToOptions-bottom").addEventListener("click", () => {
      // Same functionality as top button
      document.getElementById("backToOptions").click();
    });

    // New Test Same Options button functionality
    document.getElementById("newTestSameOptions").addEventListener("click", () => {
      // Start a new test with the same filters but different question selection
      if (AppState.isDbMode) {
        // For database mode, re-run the database query to get a new set of questions
        rerunDatabaseTest();
      } else {
        // For JSON mode, restart with the same filters (questions will be reshuffled)
        if (AppState.lastFilteredQuestions && AppState.lastFilteredQuestions.length > 0) {
          AppState.explanationMode = AppState.lastExplanationMode;
          startTest(AppState.lastFilteredQuestions);
        } else {
          startTest(AppState.originalData.questions);
        }
      }
    });

    document.getElementById("newTestSameOptions-bottom").addEventListener("click", () => {
      // Same functionality as top button
      document.getElementById("newTestSameOptions").click();
    });

    document.getElementById("newtest").addEventListener("click", () => {
      document.getElementById("test").innerHTML = "";
      document.getElementById("scoreboard").innerHTML = "";
      document.getElementById("restart").style.display = "none";
      document.getElementById("restart-bottom").style.display = "none";
      document.getElementById("backToOptions").style.display = "none";
      document.getElementById("backToOptions-bottom").style.display = "none";
      document.getElementById("newTestSameOptions").style.display = "none";
      document.getElementById("newTestSameOptions-bottom").style.display = "none";
      document.getElementById("newtest").style.display = "none";
      document.getElementById("file-chosen").innerHTML = "";
      document.getElementById("filter-panel").innerHTML = "";
      resetWorkflow();
      document.getElementById("fileInput").value = ""; // reset file input
    });

    // Set current year in footer
    document.addEventListener('DOMContentLoaded', function() {
      var y = new Date().getFullYear();
      var el = document.getElementById('swamys-copyright-year');
      if (el) el.textContent = y;
    });
  </script>
</body>
</html>
