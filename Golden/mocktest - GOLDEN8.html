<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mock Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f4f6f8;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    header {
      background: #0078d7;
      color: white;
      width: 100%;
      padding: 20px;
      text-align: center;
      font-size: 1.5em;
      font-weight: bold;
    }
    main {
      max-width: 900px;
      width: 95%;
      margin: 20px auto;
    }
    .controls {
      margin: 20px 0;
      text-align: center;
    }
    #fileInput { display: none; }
    .custom-btn {
      background: #0078d7;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1em;
    }
    .custom-btn:hover { background: #005ea3; }
    .file-chosen {
      margin: 10px auto;
      padding: 10px;
      background: #e6ffed;
      border: 1px solid #00a854;
      border-radius: 6px;
      text-align: center;
      font-weight: bold;
      color: #006633;
    }
    .question-card {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      border: 2px solid transparent;
    }
    .question-card h3 { margin-top: 0; }
    .correct { color: green; font-weight: bold; }
    .wrong { color: red; font-weight: bold; }
    .explanation { margin-top: 8px; font-style: italic; }
    .reference { margin-top: 4px; font-size: 0.9em; color: #333; }
    .disabled { pointer-events: none; opacity: 0.6; }
    .active { border: 2px solid #0078d7; box-shadow: 0 0 8px rgba(0,120,215,0.6); }
    .locked { pointer-events: none; opacity: 1 !important; }
    button {
      background: #0078d7;
      color: white;
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.95em;
      margin-top: 8px;
    }
    button:hover { background: #005ea3; }
    #restart, #newtest { margin: 20px 10px; display: none; }
    #scoreboard {
      margin: 20px 0;
      font-size: 1.2em;
      text-align: center;
    }
    #message {
      font-size: 1.1em;
      margin-top: 10px;
      font-weight: bold;
    }
    #message.excellent { color: green; }
    #message.good { color: #0078d7; }
    #message.fair { color: orange; }
    #message.poor { color: red; }
    .filter-panel {
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 20px;
      margin: 10px 0 20px 0;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .filter-panel h3 {
      margin-top: 0;
      color: #0078d7;
    }
    .filter-section { margin-bottom: 15px; }
    label { cursor: pointer; }
    .match-table {
      display: table;
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0;
    }
    .match-row { display: table-row; }
    .match-cell {
      display: table-cell;
      padding: 6px 8px;
      vertical-align: middle;
    }
    .match-cell:first-child {
      font-weight: bold;
      width: 40%;
    }
    select {
      width: 100%;
      padding: 4px;
    }
  </style>
  <!-- Add sql.js library for SQLite in browser -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
</head>
<body>
  <header id="test-title">Mock Test Application</header>
  <main>
    <div class="controls">
      <label for="fileInput" class="custom-btn" title="Select a test JSON file to begin. Loads questions and allows you to set filters before starting the test.">üìÇ Choose Test</label>
      <input type="file" id="fileInput" accept=".json">
      <button id="chooseDb" class="custom-btn" style="margin-left:10px;" title="Choose questions from the SQLite database. Allows you to set filters and select the number of questions.">üóÑÔ∏è Choose from DB</button>
      <button id="restart" style="display:none; margin-left:10px;" title="Restart the current test instantly using the same filters and explanation mode. Does not show the filter screen again.">üîÑ Restart Test</button>
    </div>
    <div id="file-chosen"></div>
    <div id="filter-panel"></div>
    <div id="test"></div>
    <div id="scoreboard"></div>
    <div style="text-align:center;">
      <button id="newtest" title="Select a new test file. Clears all current progress and lets you load a different set of questions.">üìÇ Select New Test</button>
    </div>
  </main>

  <script>
    let questions = [];
    let originalData = null;
    let score = 0;
    let explanationMode = 1;
    let db = null;
    // Store last used filters for restart
    let lastFilteredQuestions = null;
    let lastExplanationMode = 1;

    function resetWorkflow() {
      // Clear all variables
      questions = [];
      originalData = null;
      score = 0;
      explanationMode = 1;

      // Clear DOM
      document.getElementById("test").innerHTML = "";
      document.getElementById("scoreboard").innerHTML = "";
      document.getElementById("restart").style.display = "none";
      document.getElementById("newtest").style.display = "none";
      document.getElementById("file-chosen").innerHTML = "";
      document.getElementById("filter-panel").innerHTML = "";
      document.getElementById("test-title").textContent = "Mock Test Application";
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    document.getElementById("fileInput").addEventListener("change", function(e) {
      const file = e.target.files[0];
      if (!file) return;

      // If a test is already loaded, reset workflow instead of reload
      if (originalData !== null || questions.length > 0) {
        resetWorkflow();
      }
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const data = JSON.parse(event.target.result);
          originalData = data;
          document.getElementById("file-chosen").innerHTML =
            `‚úÖ Test loaded: <strong>${data.title || file.name}</strong>`;
          buildFilterPanel(data.questions);
        } catch (err) {
          alert("Invalid JSON file.");
        }
      };
      reader.readAsText(file);
      e.target.value = ""; // allow re-selecting the same file again
    });

    function setupAllCheckbox(sectionDiv) {
      const checkboxes = sectionDiv.querySelectorAll("input[type=checkbox]");
      const allBox = checkboxes[0];
      const children = Array.from(checkboxes).slice(1);

      allBox.addEventListener("change", () => {
        children.forEach(cb => cb.checked = allBox.checked);
      });

      children.forEach(cb => {
        cb.addEventListener("change", () => {
          if (children.every(c => c.checked)) {
            allBox.checked = true;
          } else {
            allBox.checked = false;
          }
        });
      });
    }

    function buildFilterPanel(allQuestions) {
      const panel = document.getElementById("filter-panel");
      panel.innerHTML = "";

      const topics = [...new Set(allQuestions.map(q => q.topic))];
      const types = [...new Set(allQuestions.map(q => q.type))];

      const wrapper = document.createElement("div");
      wrapper.className = "filter-panel";

      // Topics
      const topicDiv = document.createElement("div");
      topicDiv.className = "filter-section";
      topicDiv.innerHTML = "<h3>Select Topics</h3>";
      const allTopics = document.createElement("label");
      allTopics.innerHTML = `<input type="checkbox" value="ALL" checked> ALL`;
      topicDiv.appendChild(allTopics);
      topics.forEach(t => {
        const l = document.createElement("label");
        l.style.display = "block";
        l.innerHTML = `<input type="checkbox" value="${t}" checked> ${t}`;
        topicDiv.appendChild(l);
      });
      setupAllCheckbox(topicDiv);

      // Types
      const typeDiv = document.createElement("div");
      typeDiv.className = "filter-section";
      typeDiv.innerHTML = "<h3>Select Question Types</h3>";
      const allTypes = document.createElement("label");
      allTypes.innerHTML = `<input type="checkbox" value="ALL" checked> ALL`;
      typeDiv.appendChild(allTypes);
      types.forEach(t => {
        const l = document.createElement("label");
        l.style.display = "block";
        l.innerHTML = `<input type="checkbox" value="${t}" checked> ${t}`;
        typeDiv.appendChild(l);
      });
      setupAllCheckbox(typeDiv);

      // Explanation display mode
      const expDiv = document.createElement("div");
      expDiv.className = "filter-section";
      expDiv.innerHTML = "<h3>Explanation & Reference Display</h3>";
      expDiv.innerHTML += `
        <label><input type="radio" name="expMode" value="1" checked> Only when wrong</label><br>
        <label><input type="radio" name="expMode" value="2"> Both when right and wrong</label><br>
        <label><input type="radio" name="expMode" value="3"> Do not display explanations</label>
      `;

      // Number of questions
      const numDiv = document.createElement("div");
      numDiv.className = "filter-section";
      numDiv.innerHTML = `<h3>Number of Questions</h3><input type=\"number\" id=\"numQuestions\" min=\"10\" value=\"10\"> <span id=\"maxQuestionsInfo\" style=\"margin-left:10px; color:#0078d7; font-weight:bold;\"></span>`;

      // Add question count display at the top
      const countDiv = document.createElement("div");
      countDiv.id = "db-question-count";
      countDiv.style = "margin-bottom: 10px; font-size: 1.1em; color: #0078d7; font-weight: bold; text-align: center;";
      // Initial count
      function updateCountDisplay() {
        let selectedTopics = [];
        let selectedTypes = [];
        const topicChecks = topicDiv.querySelectorAll("input[type=checkbox]");
        if (topicChecks[0].checked) {
          selectedTopics = topics;
        } else {
          topicChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTopics.push(cb.value);
          });
        }
        const typeChecks = typeDiv.querySelectorAll("input[type=checkbox]");
        if (typeChecks[0].checked) {
          selectedTypes = types;
        } else {
          typeChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTypes.push(cb.value);
          });
        }
        let sql;
        if (selectedTopics.length === 0 || selectedTypes.length === 0) {
          sql = `SELECT COUNT(*) FROM questions`;
        } else {
          sql = `SELECT COUNT(*) FROM questions WHERE topic IN (${selectedTopics.map(t => `'${t}'`).join(',')}) AND question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
        }
        const res = db.exec(sql);
        const maxQuestions = res[0]?.values[0][0] || 0;
        countDiv.textContent = `Questions available for selection: ${maxQuestions}`;
        // Also update max for numQuestions input
        const numInput = document.getElementById("numQuestions");
        numInput.max = maxQuestions;
        if (parseInt(numInput.value) > maxQuestions) numInput.value = maxQuestions;
      }
      topicDiv.addEventListener("change", updateCountDisplay);
      typeDiv.addEventListener("change", updateCountDisplay);
      setTimeout(updateCountDisplay, 100);
      wrapper.appendChild(countDiv);

      // Start button
      const startBtn = document.createElement("button");
      startBtn.textContent = "Start Test";
      startBtn.addEventListener("click", () => {
        document.getElementById("file-chosen").innerHTML = "Loading questions from database and building test...";
        // Get selected topics and types
        let selectedTopics = [];
        let selectedTypes = [];
        const topicChecks = topicDiv.querySelectorAll("input[type=checkbox]");
        if (topicChecks[0].checked) {
          selectedTopics = topics;
        } else {
          topicChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTopics.push(cb.value);
          });
        }
        const typeChecks = typeDiv.querySelectorAll("input[type=checkbox]");
        if (typeChecks[0].checked) {
          selectedTypes = types;
        } else {
          typeChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTypes.push(cb.value);
          });
        }

        const expChoice = expDiv.querySelector("input[name=expMode]:checked");
        explanationMode = parseInt(expChoice.value);

        // Query DB for count
        let sql = `SELECT COUNT(*) FROM questions WHERE topic IN (${selectedTopics.map(t => `'${t}'`).join(',')}) AND question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
        const res = db.exec(sql);
        const maxQuestions = res[0]?.values[0][0] || 0;
        const numQuestions = Math.max(10, Math.min(parseInt(document.getElementById("numQuestions").value), maxQuestions));
        if (numQuestions > maxQuestions) {
          document.getElementById("file-chosen").innerHTML = `<span style='color:red;'>You requested ${numQuestions} questions, but only ${maxQuestions} are available for the selected criteria. Please reduce the number.</span>`;
          return;
        }

        document.getElementById("file-chosen").innerHTML = "Loading questions from database and building test...";
        // Query DB for matching questions
        let sql2 = `SELECT * FROM questions WHERE topic IN (${selectedTopics.map(t => `'${t}'`).join(',')}) AND question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
        const res2 = db.exec(sql2);
        if (!res2.length) {
          document.getElementById("file-chosen").innerHTML = "No questions found in the database for the selected filters.";
          alert("No questions found in the database for the selected filters.");
          return;
        }
        let allQuestions = res2[0]?.values.map(row => {
          const obj = {};
          res2[0].columns.forEach((col, i) => obj[col] = row[i]);
          return obj;
        }) || [];
        // Build valid question objects
        let validQuestions = [];
        allQuestions.forEach(q => {
          let valid = false;
          // MCQ: fetch options
          if (q.question_type === 'MCQ') {
            const optRes = db.exec(`SELECT option_text, is_correct FROM options WHERE question_id = ${q.id}`);
            q.options = optRes[0]?.values.map(v => v[0]) || [];
            q.answer = optRes[0]?.values.filter(v => v[1] === 1).map(v => v[0]);
            if (q.answer.length === 1) q.answer = q.answer[0];
            valid = q.options.length > 0;
            q.type = (Array.isArray(q.answer) && q.answer.length > 1) ? 'multiple' : 'single';
          }
          // TrueFalse: set options and answer
          if (q.question_type === 'TrueFalse') {
            q.options = ["True", "False"];
            // Fetch correct answer from options table
            const optRes = db.exec(`SELECT option_text, is_correct FROM options WHERE question_id = ${q.id}`);
            const correctOpt = optRes[0]?.values.find(v => v[1] === 1);
            q.answer = correctOpt ? correctOpt[0] : null;
            valid = true;
            q.type = 'single';
          }
          // Match: fetch pairs
          if (q.question_type === 'Match') {
            const matchRes = db.exec(`SELECT left_text, right_text FROM match_pairs WHERE question_id = ${q.id}`);
            q.matchPairs = {};
            q.matchPairsRaw = matchRes;
            if (matchRes[0] && matchRes[0].values && matchRes[0].values.length > 0) {
              matchRes[0].values.forEach(v => { q.matchPairs[v[0]] = v[1]; });
              valid = Object.keys(q.matchPairs).length > 0;
            } else {
              valid = false;
            }
            q.type = 'match';
          }
          // AssertionReason: fetch assertion/reason/correct_option
          if (q.question_type === 'AssertionReason') {
            const arRes = db.exec(`SELECT assertion, reason, correct_option FROM assertion_reason WHERE question_id = ${q.id}`);
            if (arRes[0]?.values.length) {
              q.assertion = arRes[0].values[0][0];
              q.reason = arRes[0].values[0][1];
              q.answer = arRes[0].values[0][2];
              // Standard options for assertion-reason
              q.options = [
                "Both A and R are true, and R explains A",
                "Both A and R are true, but R does not explain A",
                "A is true, R is false",
                "A is false, R is true",
                "Both A and R are false"
              ];
              valid = true;
            }
            q.type = 'assertion';
          }
          q.question = q.question_text;
          // Only push if valid
          if (valid) validQuestions.push(q);
        });
        // Shuffle and pick N
        validQuestions = shuffle(validQuestions);
        const chosenQuestions = validQuestions.slice(0, numQuestions);
        if (chosenQuestions.length === 0) {
          document.getElementById("file-chosen").innerHTML = "No valid questions found for the selected filters. Please try different options.";
          return;
        }
        // Debug: Show first question object
        document.getElementById("file-chosen").innerHTML = `<pre>First question object:\n${JSON.stringify(chosenQuestions[0], null, 2)}</pre>Loaded ${chosenQuestions.length} questions. Preparing test UI...`;
        setTimeout(() => {
          panel.innerHTML = ""; // Clear filter panel before starting test
          document.getElementById("restart").style.display = "none"; // Hide restart until questions are shown
          startTest(chosenQuestions);
        }, 1500);
      });

      // Update max questions info and input limit dynamically
      function updateMaxQuestions() {
        // Get selected topics and types
        let selectedTopics = [];
        let selectedTypes = [];
        const topicChecks = topicDiv.querySelectorAll("input[type=checkbox]");
        if (topicChecks[0].checked) {
          selectedTopics = topics;
        } else {
          topicChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTopics.push(cb.value);
          });
        }
        const typeChecks = typeDiv.querySelectorAll("input[type=checkbox]");
        if (typeChecks[0].checked) {
          selectedTypes = types;
        } else {
          typeChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTypes.push(cb.value);
          });
        }
        // Query DB for count
        let sql = `SELECT COUNT(*) FROM questions WHERE topic IN (${selectedTopics.map(t => `'${t}'`).join(',')}) AND question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
        const res = db.exec(sql);
        const maxQuestions = res[0]?.values[0][0] || 0;
        document.getElementById("maxQuestionsInfo").textContent = `Max: ${maxQuestions}`;
        const numInput = document.getElementById("numQuestions");
        numInput.max = maxQuestions;
        if (parseInt(numInput.value) > maxQuestions) numInput.value = maxQuestions;
        // Disable start button if invalid
        startBtn.disabled = (maxQuestions < 10 || parseInt(numInput.value) > maxQuestions);
      }
      // Attach listeners to topic/type checkboxes and numQuestions input
      topicDiv.addEventListener("change", updateMaxQuestions);
      typeDiv.addEventListener("change", updateMaxQuestions);
      setTimeout(() => {
        const numInput = document.getElementById("numQuestions");
        if (numInput) numInput.addEventListener("input", updateMaxQuestions);
        updateMaxQuestions();
      }, 0);
      wrapper.appendChild(topicDiv);
      wrapper.appendChild(typeDiv);
      wrapper.appendChild(expDiv);
      wrapper.appendChild(numDiv);
      wrapper.appendChild(startBtn);
      panel.appendChild(wrapper);
    }

    document.getElementById("chooseDb").addEventListener("click", async () => {
      // Clear all DOMs and reset state before showing DB filter panel
      document.getElementById("test").innerHTML = "";
      document.getElementById("scoreboard").innerHTML = "";
      document.getElementById("restart").style.display = "none";
      document.getElementById("newtest").style.display = "none";
      document.getElementById("file-chosen").innerHTML = "Connecting to database...";
      document.getElementById("filter-panel").innerHTML = "";
      // Prompt user to select the SQLite DB file
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".db";
      input.style.display = "none";
      document.body.appendChild(input);
      input.click();
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        document.getElementById("file-chosen").innerHTML = "Loading database file...";
        try {
          const arrayBuffer = await file.arrayBuffer();
          const SQL = await initSqlJs({ locateFile: fileName => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${fileName}` });
          db = new SQL.Database(new Uint8Array(arrayBuffer));
          document.getElementById("file-chosen").innerHTML = "Database loaded. Fetching topics and question types...";
          // Fetch topics and types
          const topicsRes = db.exec("SELECT DISTINCT topic FROM questions");
          const typesRes = db.exec("SELECT DISTINCT question_type FROM questions");
          const countRes = db.exec("SELECT COUNT(*) FROM questions");
          const totalQuestions = countRes[0]?.values[0][0] || 0;
          const topics = topicsRes[0]?.values.map(v => v[0]) || [];
          const types = typesRes[0]?.values.map(v => v[0]) || [];
          if (topics.length === 0 || types.length === 0) {
            document.getElementById("file-chosen").innerHTML = "No topics or question types found in the database.";
            return;
          }
          document.getElementById("file-chosen").innerHTML = `Database ready. Total questions: <strong>${totalQuestions}</strong>. Please select filters and number of questions.`;
          buildDbFilterPanel(topics, types);
        } catch (err) {
          document.getElementById("file-chosen").innerHTML = "Error loading database: " + err.message;
        }
        document.body.removeChild(input);
      };
    });

    function buildDbFilterPanel(topics, types) {
      const panel = document.getElementById("filter-panel");
      panel.innerHTML = "";
      const wrapper = document.createElement("div");
      wrapper.className = "filter-panel";

      // Topics
      const topicDiv = document.createElement("div");
      topicDiv.className = "filter-section";
      topicDiv.innerHTML = "<h3>Select Topics</h3>";
      const allTopics = document.createElement("label");
      allTopics.innerHTML = `<input type=\"checkbox\" value=\"ALL\" checked> ALL`;
      topicDiv.appendChild(allTopics);
      topics.forEach(t => {
        const l = document.createElement("label");
        l.style.display = "block";
        l.innerHTML = `<input type=\"checkbox\" value=\"${t}\" checked> ${t}`;
        topicDiv.appendChild(l);
      });
      setupAllCheckbox(topicDiv);

      // Types
      const typeDiv = document.createElement("div");
      typeDiv.className = "filter-section";
      typeDiv.innerHTML = "<h3>Select Question Types</h3>";
      const allTypes = document.createElement("label");
      allTypes.innerHTML = `<input type=\"checkbox\" value=\"ALL\" checked> ALL`;
      typeDiv.appendChild(allTypes);
      types.forEach(t => {
        const l = document.createElement("label");
        l.style.display = "block";
        l.innerHTML = `<input type=\"checkbox\" value=\"${t}\" checked> ${t}`;
        typeDiv.appendChild(l);
      });
      setupAllCheckbox(typeDiv);

      // Explanation display mode
      const expDiv = document.createElement("div");
      expDiv.className = "filter-section";
      expDiv.innerHTML = "<h3>Explanation & Reference Display</h3>";
      expDiv.innerHTML += `
        <label><input type=\"radio\" name=\"expMode\" value=\"1\" checked> Only when wrong</label><br>
        <label><input type=\"radio\" name=\"expMode\" value=\"2\"> Both when right and wrong</label><br>
        <label><input type=\"radio\" name=\"expMode\" value=\"3\"> Do not display explanations</label>
      `;

      // Number of questions
      const numDiv = document.createElement("div");
      numDiv.className = "filter-section";
      numDiv.innerHTML = `<h3>Number of Questions</h3><input type=\"number\" id=\"numQuestions\" min=\"10\" value=\"10\"> <span id=\"maxQuestionsInfo\" style=\"margin-left:10px; color:#0078d7; font-weight:bold;\"></span>`;

      // Add question count display at the top
      const countDiv = document.createElement("div");
      countDiv.id = "db-question-count";
      countDiv.style = "margin-bottom: 10px; font-size: 1.1em; color: #0078d7; font-weight: bold; text-align: center;";
      // Initial count
      function updateCountDisplay() {
        let selectedTopics = [];
        let selectedTypes = [];
        const topicChecks = topicDiv.querySelectorAll("input[type=checkbox]");
        if (topicChecks[0].checked) {
          selectedTopics = topics;
        } else {
          topicChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTopics.push(cb.value);
          });
        }
        const typeChecks = typeDiv.querySelectorAll("input[type=checkbox]");
        if (typeChecks[0].checked) {
          selectedTypes = types;
        } else {
          typeChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTypes.push(cb.value);
          });
        }
        let sql;
        if (selectedTopics.length === 0 || selectedTypes.length === 0) {
          sql = `SELECT COUNT(*) FROM questions`;
        } else {
          sql = `SELECT COUNT(*) FROM questions WHERE topic IN (${selectedTopics.map(t => `'${t}'`).join(',')}) AND question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
        }
        const res = db.exec(sql);
        const maxQuestions = res[0]?.values[0][0] || 0;
        countDiv.textContent = `Questions available for selection: ${maxQuestions}`;
        // Also update max for numQuestions input
        const numInput = document.getElementById("numQuestions");
        numInput.max = maxQuestions;
        if (parseInt(numInput.value) > maxQuestions) numInput.value = maxQuestions;
      }
      topicDiv.addEventListener("change", updateCountDisplay);
      typeDiv.addEventListener("change", updateCountDisplay);
      setTimeout(updateCountDisplay, 100);
      wrapper.appendChild(countDiv);

      // Start button
      const startBtn = document.createElement("button");
      startBtn.textContent = "Start Test";
      startBtn.addEventListener("click", () => {
        document.getElementById("file-chosen").innerHTML = "Loading questions from database and building test...";
        // Get selected topics and types
        let selectedTopics = [];
        let selectedTypes = [];
        const topicChecks = topicDiv.querySelectorAll("input[type=checkbox]");
        if (topicChecks[0].checked) {
          selectedTopics = topics;
        } else {
          topicChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTopics.push(cb.value);
          });
        }
        const typeChecks = typeDiv.querySelectorAll("input[type=checkbox]");
        if (typeChecks[0].checked) {
          selectedTypes = types;
        } else {
          typeChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTypes.push(cb.value);
          });
        }

        const expChoice = expDiv.querySelector("input[name=expMode]:checked");
        explanationMode = parseInt(expChoice.value);

        // Query DB for count
        let sql = `SELECT COUNT(*) FROM questions WHERE topic IN (${selectedTopics.map(t => `'${t}'`).join(',')}) AND question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
        const res = db.exec(sql);
        const maxQuestions = res[0]?.values[0][0] || 0;
        const numQuestions = Math.max(10, Math.min(parseInt(document.getElementById("numQuestions").value), maxQuestions));
        if (numQuestions > maxQuestions) {
          document.getElementById("file-chosen").innerHTML = `<span style='color:red;'>You requested ${numQuestions} questions, but only ${maxQuestions} are available for the selected criteria. Please reduce the number.</span>`;
          return;
        }

        document.getElementById("file-chosen").innerHTML = "Loading questions from database and building test...";
        // Query DB for matching questions
        let sql2 = `SELECT * FROM questions WHERE topic IN (${selectedTopics.map(t => `'${t}'`).join(',')}) AND question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
        const res2 = db.exec(sql2);
        if (!res2.length) {
          document.getElementById("file-chosen").innerHTML = "No questions found in the database for the selected filters.";
          alert("No questions found in the database for the selected filters.");
          return;
        }
        let allQuestions = res2[0]?.values.map(row => {
          const obj = {};
          res2[0].columns.forEach((col, i) => obj[col] = row[i]);
          return obj;
        }) || [];
        // Build valid question objects
        let validQuestions = [];
        allQuestions.forEach(q => {
          let valid = false;
          // MCQ: fetch options
          if (q.question_type === 'MCQ') {
            const optRes = db.exec(`SELECT option_text, is_correct FROM options WHERE question_id = ${q.id}`);
            q.options = optRes[0]?.values.map(v => v[0]) || [];
            q.answer = optRes[0]?.values.filter(v => v[1] === 1).map(v => v[0]);
            if (q.answer.length === 1) q.answer = q.answer[0];
            valid = q.options.length > 0;
            q.type = (Array.isArray(q.answer) && q.answer.length > 1) ? 'multiple' : 'single';
          }
          // TrueFalse: set options and answer
          if (q.question_type === 'TrueFalse') {
            q.options = ["True", "False"];
            // Fetch correct answer from options table
            const optRes = db.exec(`SELECT option_text, is_correct FROM options WHERE question_id = ${q.id}`);
            const correctOpt = optRes[0]?.values.find(v => v[1] === 1);
            q.answer = correctOpt ? correctOpt[0] : null;
            valid = true;
            q.type = 'single';
          }
          // Match: fetch pairs
          if (q.question_type === 'Match') {
            const matchRes = db.exec(`SELECT left_text, right_text FROM match_pairs WHERE question_id = ${q.id}`);
            q.matchPairs = {};
            q.matchPairsRaw = matchRes;
            if (matchRes[0] && matchRes[0].values && matchRes[0].values.length > 0) {
              matchRes[0].values.forEach(v => { q.matchPairs[v[0]] = v[1]; });
              valid = Object.keys(q.matchPairs).length > 0;
            } else {
              valid = false;
            }
            q.type = 'match';
          }
          // AssertionReason: fetch assertion/reason/correct_option
          if (q.question_type === 'AssertionReason') {
            const arRes = db.exec(`SELECT assertion, reason, correct_option FROM assertion_reason WHERE question_id = ${q.id}`);
            if (arRes[0]?.values.length) {
              q.assertion = arRes[0].values[0][0];
              q.reason = arRes[0].values[0][1];
              q.answer = arRes[0].values[0][2];
              // Standard options for assertion-reason
              q.options = [
                "Both A and R are true, and R explains A",
                "Both A and R are true, but R does not explain A",
                "A is true, R is false",
                "A is false, R is true",
                "Both A and R are false"
              ];
              valid = true;
            }
            q.type = 'assertion';
          }
          q.question = q.question_text;
          // Only push if valid
          if (valid) validQuestions.push(q);
        });
        // Shuffle and pick N
        validQuestions = shuffle(validQuestions);
        const chosenQuestions = validQuestions.slice(0, numQuestions);
        if (chosenQuestions.length === 0) {
          document.getElementById("file-chosen").innerHTML = "No valid questions found for the selected filters. Please try different options.";
          return;
        }
        // Debug: Show first question object
        document.getElementById("file-chosen").innerHTML = `<pre>First question object:\n${JSON.stringify(chosenQuestions[0], null, 2)}</pre>Loaded ${chosenQuestions.length} questions. Preparing test UI...`;
        setTimeout(() => {
          panel.innerHTML = ""; // Clear filter panel before starting test
          document.getElementById("restart").style.display = "none"; // Hide restart until questions are shown
          startTest(chosenQuestions);
        }, 1500);
      });

      // Update max questions info and input limit dynamically
      function updateMaxQuestions() {
        // Get selected topics and types
        let selectedTopics = [];
        let selectedTypes = [];
        const topicChecks = topicDiv.querySelectorAll("input[type=checkbox]");
        if (topicChecks[0].checked) {
          selectedTopics = topics;
        } else {
          topicChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTopics.push(cb.value);
          });
        }
        const typeChecks = typeDiv.querySelectorAll("input[type=checkbox]");
        if (typeChecks[0].checked) {
          selectedTypes = types;
        } else {
          typeChecks.forEach((cb, i) => {
            if (i > 0 && cb.checked) selectedTypes.push(cb.value);
          });
        }
        // Query DB for count
        let sql = `SELECT COUNT(*) FROM questions WHERE topic IN (${selectedTopics.map(t => `'${t}'`).join(',')}) AND question_type IN (${selectedTypes.map(t => `'${t}'`).join(',')})`;
        const res = db.exec(sql);
        const maxQuestions = res[0]?.values[0][0] || 0;
        document.getElementById("maxQuestionsInfo").textContent = `Max: ${maxQuestions}`;
        const numInput = document.getElementById("numQuestions");
        numInput.max = maxQuestions;
        if (parseInt(numInput.value) > maxQuestions) numInput.value = maxQuestions;
        // Disable start button if invalid
        startBtn.disabled = (maxQuestions < 10 || parseInt(numInput.value) > maxQuestions);
      }
      // Attach listeners to topic/type checkboxes and numQuestions input
      topicDiv.addEventListener("change", updateMaxQuestions);
      typeDiv.addEventListener("change", updateMaxQuestions);
      setTimeout(() => {
        const numInput = document.getElementById("numQuestions");
        if (numInput) numInput.addEventListener("input", updateMaxQuestions);
        updateMaxQuestions();
      }, 0);
      wrapper.appendChild(topicDiv);
      wrapper.appendChild(typeDiv);
      wrapper.appendChild(expDiv);
      wrapper.appendChild(numDiv);
      wrapper.appendChild(startBtn);
      panel.appendChild(wrapper);
    }

    // Utility: Show total question count in DB in file-chosen area for debugging
    function showTotalDbQuestions() {
      if (!db) return;
      const res = db.exec('SELECT COUNT(*) FROM questions');
      const total = res[0]?.values[0][0] || 0;
      document.getElementById('file-chosen').innerHTML = `<span style='color:#0078d7; font-weight:bold;'>Total questions in DB: ${total}</span>`;
    }
    // Call this after DB loads
    if (typeof showTotalDbQuestions === 'function') setTimeout(showTotalDbQuestions, 500);

    function startTest(filteredQuestions) {
      try {
        document.getElementById("file-chosen").innerHTML = "";
        const container = document.getElementById("test");
        container.innerHTML = "";
        document.getElementById("restart").style.display = "inline-block";
        document.getElementById("newtest").style.display = "none";
        document.getElementById("scoreboard").innerHTML = "";
        score = 0;
        document.getElementById("test-title").textContent = originalData?.title || "Mock Test";
        // Absolute random shuffle for questions
        const shuffledQuestions = shuffle(filteredQuestions.map(q => ({ ...q })));
        // Absolute random shuffle for options in every question
        questions = shuffledQuestions.map(q => {
          if (q.options) q.options = shuffle([...q.options]);
          return q;
        });
        // Save last used filters for restart
        lastFilteredQuestions = questions.map(q => ({ ...q }));
        lastExplanationMode = explanationMode;
        renderTest(questions);
      } catch (err) {
        document.getElementById("file-chosen").innerHTML = `<pre style='color:red;'>Error rendering test: ${err.message}</pre>`;
        document.getElementById("test").innerHTML = "";
      }
    }

    function renderTest(questions) {
      try {
        if (!Array.isArray(questions) || questions.length === 0) {
          document.getElementById("file-chosen").innerHTML = `<pre style='color:red;'>Error: No questions to display. Please check your filters or database content.</pre>`;
          document.getElementById("test").innerHTML = "";
          return;
        }
        const container = document.getElementById("test");
        container.innerHTML = "";   // ensure fresh start always
        questions.forEach((q, qIndex) => {
          const qDiv = document.createElement("div");
          qDiv.className = "question-card";
          qDiv.id = `q-${q.id}`;

          const qTitle = document.createElement("h3");
          qTitle.textContent = `${qIndex + 1}. ${q.question}`;
          qDiv.appendChild(qTitle);

          if ((q.type === "single" || q.type === "assertion") && Array.isArray(q.options)) {
            q.options.forEach(opt => {
              const label = document.createElement("label");
              label.style.display = "block";
              const input = document.createElement("input");
              input.type = "radio";
              input.name = `q${q.id}`;
              input.value = opt;
              input.addEventListener("change", () => {
                handleAnswer(q, [opt], qDiv, qIndex);
              });
              label.appendChild(input);
              label.append(" " + opt);
              qDiv.appendChild(label);
            });
          }
          else if (q.type === "multiple" && Array.isArray(q.options)) {
            q.options.forEach(opt => {
              const label = document.createElement("label");
              label.style.display = "block";
              const input = document.createElement("input");
              input.type = "checkbox";
              input.name = `q${q.id}`;
              input.value = opt;
              label.appendChild(input);
              label.append(" " + opt);
              qDiv.appendChild(label);
            });

            const submitBtn = document.createElement("button");
            submitBtn.textContent = "Submit Answer";
            submitBtn.title = "Submit your selected answers for this question. You can select multiple options.";
            submitBtn.addEventListener("click", () => {
              const selected = Array.from(qDiv.querySelectorAll("input[type=checkbox]:checked"))
                .map(cb => cb.value);
              handleAnswer(q, selected, qDiv, qIndex);
            });
            qDiv.appendChild(submitBtn);
          }
          else if (q.type === "match" && q.matchPairs && typeof q.matchPairs === 'object' && Object.keys(q.matchPairs).length > 0) {
            const keys = Object.keys(q.matchPairs);
            const values = shuffle(Object.values(q.matchPairs));

            const table = document.createElement("div");
            table.className = "match-table";

            const selects = [];

            keys.forEach(k => {
              const row = document.createElement("div");
              row.className = "match-row";

              const left = document.createElement("div");
              left.className = "match-cell";
              left.textContent = k;

              const right = document.createElement("div");
              right.className = "match-cell";
              const select = document.createElement("select");

              const placeholder = document.createElement("option");
              placeholder.value = "";
              placeholder.textContent = "<Select One>";
              placeholder.disabled = true;
              placeholder.selected = true;
              select.appendChild(placeholder);

              values.forEach(v => {
                const opt = document.createElement("option");
                opt.value = v;
                opt.textContent = v;
                select.appendChild(opt);
              });

              selects.push(select);
              right.appendChild(select);
              row.appendChild(left);
              row.appendChild(right);
              table.appendChild(row);
            });

            qDiv.appendChild(table);

            const submitBtn = document.createElement("button");
            submitBtn.textContent = "Submit Matches";
            submitBtn.title = "Submit your selected matches for this question. Match each item on the left to the correct option on the right.";
            submitBtn.disabled = true;

            selects.forEach(sel => {
              sel.addEventListener("change", () => {
                const allFilled = selects.every(s => s.value !== "");
                submitBtn.disabled = !allFilled;
              });
            });

            submitBtn.addEventListener("click", () => {
              const selections = {};
              keys.forEach((k, i) => {
                selections[k] = selects[i].value;
              });
              handleAnswer(q, selections, qDiv, qIndex);
            });

            qDiv.appendChild(submitBtn);
          }
          else {
            // If data is missing or malformed, show a message
            qDiv.innerHTML += `<div style='color:red;'>Error: Question data is incomplete or malformed.</div>`;
          }

          container.appendChild(qDiv);
        });

        // After all question cards are created, set disabled/active classes
        questions.slice(1).forEach(q => {
          const el = document.getElementById(`q-${q.id}`);
          if (el) el.classList.add("disabled");
        });
        const firstEl = document.getElementById(`q-${questions[0]?.id}`);
        if (firstEl) firstEl.classList.add("active");
      } catch (err) {
        document.getElementById("file-chosen").innerHTML = `<pre style='color:red;'>Error rendering questions: ${err.message}</pre>`;
        document.getElementById("test").innerHTML = "";
      }
    }

    function handleAnswer(question, chosen, qDiv, qIndex) {
      if (qDiv.classList.contains("locked")) return;

      qDiv.classList.remove("active");
      qDiv.classList.add("locked");

      let isCorrect = false;

      if (question.type === "single" || question.type === "assertion") {
        isCorrect = (chosen[0] === question.answer);
      }
      else if (question.type === "multiple") {
        const correct = new Set(question.answer);
        const selected = new Set(chosen);
        isCorrect = (correct.size === selected.size && [...correct].every(x => selected.has(x)));
      }
      else if (question.type === "match") {
        isCorrect = JSON.stringify(chosen) === JSON.stringify(question.matchPairs);
      }

      if (isCorrect) {
        qDiv.insertAdjacentHTML("beforeend", `<p class="correct">‚úÖ Correct!</p>`);
        score++;
      } else {
        qDiv.insertAdjacentHTML("beforeend", `<p class="wrong">‚ùå Wrong. Correct answer: ${
          question.type === "multiple" ? question.answer.join(", ") :
          question.type === "match" ? Object.entries(question.matchPairs).map(([k,v]) => `${k} ‚Üí ${v}`).join("; ") :
          question.answer
        }</p>`);
      }

      if (explanationMode === 2 || (explanationMode === 1 && !isCorrect)) {
        if (question.explanation) {
          qDiv.insertAdjacentHTML("beforeend", `<p class="explanation">üí° Explanation: ${question.explanation}</p>`);
        }
        if (question.reference) {
          qDiv.insertAdjacentHTML("beforeend", `<p class="reference">üìñ Reference: ${question.reference}</p>`);
        }
      }

      const nextQ = document.getElementById(`q-${questions[qIndex + 1]?.id}`);
      if (nextQ) {
        nextQ.classList.remove("disabled");
        nextQ.classList.add("active");
      } else {
        showFinalScore();
      }
    }

    function showFinalScore() {
      const total = questions.length;
      const percent = Math.round((score / total) * 100);

      let message = "";
      let cssClass = "";

      if (percent >= 90) {
        message = "üåü Outstanding performance! You‚Äôve clearly mastered the material.";
        cssClass = "excellent";
      } else if (percent >= 70) {
        message = "üëç Well done! You have a strong grasp, revise the missed parts.";
        cssClass = "good";
      } else if (percent >= 50) {
        message = "üòä Decent effort! Review the gaps and practice more.";
        cssClass = "fair";
      } else {
        message = "üôå Keep trying! Revise basics and practice step by step.";
        cssClass = "poor";
      }

      document.getElementById("scoreboard").innerHTML = `
        <div><strong>Your Score:</strong> ${score} / ${total} (${percent}%)</div>
        <div id="message" class="${cssClass}">${message}</div>
      `;

      document.getElementById("restart").style.display = "inline-block";
      document.getElementById("newtest").style.display = "inline-block";
    }

    document.getElementById("restart").addEventListener("click", () => {
      // Use last filters and explanation mode for restart
      if (lastFilteredQuestions && lastFilteredQuestions.length > 0) {
        explanationMode = lastExplanationMode;
        startTest(lastFilteredQuestions);
      } else {
        startTest(originalData.questions);
      }
    });

    document.getElementById("newtest").addEventListener("click", () => {
      document.getElementById("test").innerHTML = "";
      document.getElementById("scoreboard").innerHTML = "";
      document.getElementById("restart").style.display = "none";
      document.getElementById("newtest").style.display = "none";
      document.getElementById("file-chosen").innerHTML = "";
      document.getElementById("filter-panel").innerHTML = "";
      resetWorkflow();
  document.getElementById("fileInput").value = ""; // reset file input
    });
  </script>
</body>
</html>
